---
layout:     post
title:      索引概念
subtitle:   Mysql索引结构
date:       2022-01-28
author:     王凤权
header-img: img/the-first.png
catalog:   true
tags:
    - 面试题
    - JAVA 
    - 索引
    - Mysql索引结果
    - 哈希索引与B+树索引比较


---

### 索引是什么概念，有什么作用？

数据库的索引和书籍中的目录非常相似。有了索引，就可以快速地在书中找到需要的内容，而无需顺序浏览全书了。书中的目录是主要章节的列表，其中注明了包含各章节的页码。而数据库中的索引是一个表中所包含的值的列表，其中注明了表中包含各个值的记录所在的存储位置。可以为表中的单个列建立索引，也可以为一组列建立索引。
索引提供指针以指向存储在表中指定列的数据值，然后根据指定的排序次序排列这些指针。数据库使用索引的方式与使用书的目录很相似：通过搜索索引找到特定的值，然后跟随指针到达包含该值的行。因为索引是有序排列的，所以会大大提高索引的效率。

其实想要理解索引原理，必须清楚一种数据结构：平衡树」(非二叉)，也就是b tree或者 b+ tree

当然， 有的数据库也使用哈希桶作用索引的数据结构 ， 然而， 主流的RDBMS都是把平衡树当做数据表默认的索引数据结构的。

我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。

事实上， 一个加了主键的表，并不能被称之为“表”。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐。

如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的“平衡树”结构，换句话说，就是整个表就变成了一个索引。

没错， 再说一遍， 整个表变成了一个索引！

也就是所谓的“聚集索引”。 这就是为什么一个表只能有一个主键， 一个表只能有一个“聚集索引”，因为主键的作用就是把“表”的数据格式转换成“树（索引）”的格式。

未加索引时，之前执行的查询sql会让数据库系统逐行的遍历整张表，对于每一行都要检查其class_id字段是否等于“2”。因为我们要查找所有class_id为“2”的员工，所以当我们发现了一条class_id是“2”的记录后，并不能停止继续查找，因为可能还有class_id等于“2”的其他记录。

这就意味着，对于表中的千万条记录，数据库每一条都要检查。这就是所谓的“全表扫描”（ full table scan）

而加上索引的最大作用就是加快查询速度，它能从根本上减少需要扫表的记录/行的数量。

### MySQL 里主要有哪些索引结构？

在MySQL中， 索引有两种分类方式：逻辑分类和物理分类。

按照逻辑分类，索引可分为：

主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；

唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，但是一个唯一索引只能包含一列，比如身份证号码、卡号等都可以作为唯一索引；

普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；

全文索引：让搜索关键词更高效的一种索引。

按照物理分类，索引可分为：

聚集索引：一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为 NULL 的唯一索引，如果还是没有的话，就采用 Innodb 存储引擎为每行数据内置的 6 字节 ROWID 作为聚集索引。每张表只有一个聚集索引，因为聚集索引的键值的逻辑顺序决定了表中相应行的物理顺序。聚集索引在精确查找和范围查找方面有良好的性能表现（相比于普通索引和全表扫描），聚集索引就显得弥足珍贵，聚集索引选择还是要慎重的（一般不会让没有语义的自增 id 充当聚集索引）；

非聚集索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同（非主键的那一列），一个表中可以拥有多个非聚集索引。

在目前用的最多的mysql的InnoDB存储引擎中，是使用B+Tree索引方法来进行索引建立的。

B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。

B+树中的B代表平衡（balance），而不是二叉（binary），因为B+树是从最早的平衡二叉树演化而来的。先了解二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree），B+树即由这些树逐步优化而来。

具体的讲解可参考：https://www.cnblogs.com/wuzhenzhao/p/10341114.html 该博客。

### 索引的优缺点

**优点：**

1、索引能够提高数据检索的效率，降低数据库的IO成本。

2、通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

3、在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间

4、加速两个表之间的连接，一般是在外键上创建索引

**缺点：**

1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加

2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大

3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度

### 索引何时应该使用

**需创建索引的情况**：

1.主键，自动建立唯一索引

2.频繁作为查询的条件的字段

3.查询中与其他表关联的字段存在外键关系

4.查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度

5.查询中统计或者分组字段

**避免创建索引的情况**：

1.数据唯一性差的字段不要使用索引

比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。

2.频繁更新的字段不要使用索引

比如登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。

3.字段不在where语句出现时不要添加索引

只有在where语句出现，mysql才会去使用索引

4.数据量少的表不要使用索引

使用了改善也不大

### 哪些sql能命中索引

1.前导模糊查询不能使用索引，　　如name like ‘%涛’

2、Union、in、or可以命中索引，建议使用in。

3、负条件查询不能使用索引，可以优化为in查询，其中负条件有！=、<>、not in、not exists、not like等

4、联合索引最左前缀原则，又叫最左侧查询，如果在（a，b，c）三个字段上建立联合索引，那么它能够加快a|（a，b）|（a，b，c）三组的查询速度。

5、建立联合查询时，区分度最高的字段在最左边

6、如果建立了（a，b）联合索引，就不必再单独建立a索引。同理，如果建立了（a，b，c）索引就不必再建立a，（a，b）索引

7、存在非等号和等号混合判断条件时，在建索引时，要把等号条件的列前置

8、范围列可以用到索引，但是范围列后面的列无法用到索引。

索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。范围条件有：<、<=、>、>=、between等。

9、把计算放到业务层而不是数据库层。在字段上计算不能命中索引，

10、强制类型转换会全表扫描，

如果phone字段是varcher类型，则下面的SQL不能命中索引。Select * fromuser where phone=13800001234

11、更新十分频繁、数据区分度不高的字段上不宜建立索引。

更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能。

“性别”这种区分度不太大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。

一般区分度在80%以上就可以建立索引。区分度可以使用count（distinct（列名））/count（*）来计算。

12、利用覆盖索引来进行查询操作，避免回表。

被查询的列，数据能从索引中取得，而不是通过定位符row-locator再到row上获取，即“被查询列要被所建的索引覆盖”，这能够加速度查询。

13、建立索引的列不能为null，使用not null约束及默认值

14、利用延迟关联或者子查询优化超多分页场景，

MySQL并不是跳过offset行，而是取offset+N行，然后放弃前offset行，返回N行，那当offset特别大的时候，效率非常低下，要么控制返回的总数，要么对超过特定阈值的页进行SQL改写。

15、业务上唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。

16、超过三个表最好不要用join，需要join的字段，数据类型必须一致，多表关联查询时，保证被关联的字段需要有索引。

17、如果明确知道查询结果只要一条，limit 1能够提高效率，比如验证登录的时候。

18、Select语句务必指明字段名称

19、如果排序字段没有用到索引，就尽量少排序

20、尽量用union all 代替 union。Union需要将集合合并后在进行唯一性过滤操作，这会涉及到排序，大量的cpu运算，加大资源消耗及延迟，当然，使用union all的前提条件是两个结果集没有重复数据。

### 哈希索引和 B+树索引比较？ 

#### Hash索引概念

​       说到Hash，老铁们很容易联想到HashMap，没错，Hash索引的结构和HashMap相类似，键值 key 通过 Hash 映射找到桶 bucket。在这里桶（bucket）指的是一个能存储一条或多条记录的存储单位。一个桶的结构包含了一个内存指针数组，桶中的每行数据都会指向下一行，形成链表结构，当遇到 Hash 冲突时，会在桶中进行键值的查找。

​		InnoDB中采用除法散列函数(取余法)，冲突机制采用链接法

#### Hash索引和B+tree索引查询效率

​        采用 Hash 进行检索效率非常高，基本上一次检索就可以找到数据，而 B+ 树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次 I/O 操作，理论上来说 Hash 比 B+ tree更快。下图是引用网上的Hash索引图片和 B+tree 索引图片，便于直观的理解2种索引结构。

##### 1、Hash索引图片

![img](https://img-blog.csdnimg.cn/20200712160210334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0MTY5Mw==,size_16,color_FFFFFF,t_70)

​																	图1、Hash索引结构图                                                     

##### 2、B+tree索引图片

![img](https://img-blog.csdnimg.cn/2020071217040799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0MTY5Mw==,size_16,color_FFFFFF,t_70)

​																		图2、B+tree 索引结构图 

#### Hash索引和B+tree索引的区别

      1、在查询速度上，如果是等值查询，那么Hash索引明显有绝对优势，因为只需要经过一次 Hash 算法即可找到相应的键值，复杂度为O(1)；当然了，这个前提是键值都是唯一的。如果键值不是唯一(或存在Hash冲突)，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据，这时候复杂度会变成O(n)，降低了Hash索引的查找效率。所以，Hash 索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等（当然B+tree索引也不适合这种离散型低的字段上）；
      2、Hash 索引是无序的，如果是范围查询检索，这时候 Hash 索引就无法起到作用，即使原先是有序的键值，经过 Hash 算法后，也会变成不连续的了。因此
           ①、Hash 索引只支持等值比较查询、无法索成范围查询检索，B+tree索引的叶子节点形成有序链表，便于范围查询。
           ②、Hash 索引无法做 like ‘xxx%’ 这样的部分模糊查询，因为需要对 完整 key 做 Hash 计算，定位bucket。而 B+tree 索引具有最左前缀匹配，可以进行部分模糊查询。
           ③、Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。B+tree 索引的叶子节点形成有序链表，可用于排序。
      3、Hash 索引不支持多列联合索引，对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用；
      4、因为存在哈希碰撞问题，在有大量重复键值情况下，哈希索引的效率极低。B+tree 所有查询都要找到叶子节点，性能稳定；

#### 场景区分

​      1、大多数场景下，都会有组合查询，范围查询、排序、分组、模糊查询等查询特征，Hash 索引无法满足要求，建议数据库使用B+树索引。

​		 2、在离散型高，数据基数大，且等值查询时候，Hash索引有优势。

> 原文链接：https://blog.csdn.net/weixin_43841693/article/details/107301253 

### 总结

索引是非常重要的技术！

但每建立一个索引，实际上都需要在硬盘上开辟一块空间用于存储这个索引所需要的数据结构（虽然表述不太准确但是是这个意思），因此不建议对太长的字段建立索引。

而且建立的索引并不是越多越好，因为索引虽然能够提高查询效率，但是会大大得影响插入、删除和修改的效率，因为每一次数据的更新都会牵涉到对索引的修改。

综上所述，往往在对于大量数据的插入的情况的时候，我们需要先删除掉数据表的索引，等插入完毕后重新建立索引，这样才能最大限度地保证数据库的效率！

