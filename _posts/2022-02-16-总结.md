## 面试准备

### 一、英文自我介绍准备

1.自我介绍范文（仅供参考）
Good morning/evening, my name is XXX. I’m XX years old. I came from XXX city of Guangdong province.
I graduated from Guangdong University of Petrochemical Technology in 2014. My major is computer science and technology. I have large enthusiasm in programming. I learned very hard and I have passed the CET-4 and learned Java by myself during the college.
After graduate, I found a job in a Shen zhen IT company. I have worked in this company for two years. I can mastered the mainstream developing technology such as Spring, Strust2, Hibernate, Spring MVC, Mybatis, I also can use the database like ORACLE/MYSQL; For the front end, jQuery framework such as Easy UI and Bootstrap was also involved in my work.
Now I’d like to find a job in Guangzhou ,which one I want to improve my English and technique. I’m very interested in HSBC’s opportunity and hope to join your team if possible. Thanks for your listening.

Good afternoon, I am glade to have this opportunity for the interview.
My name is XXX. You can call me Cookie. I’m 29 years old. I was born in Maoming, a beautiful city in Guangdong Province.
I graduated from Guangzhou Maritime College in 2010. My major is computer science and technology. I have 7 years of java experience now.
I like programming very much. I am capable of developing apps , web apps and back-end services. I also have experience of team management, with 14 persons in my team.
I can master mainstream developing technologies such as Spring Boot, AngularJs and TypeScript. I also would like to keep learning new technologies and put them into use in working.
I attach great importance to this opportunity in HSBC and hope to join your team if possible. Thanks for your listening.

Good morning !
It is really my honor to have this opportunity for a interview,
I hope i can make a good performance today. My name is XXX, you can call me Emily.
I am 28 years old,born in Hunan province.
I was graduated from Changsha Aeronautical Vocational and Technical College. my major is Software Engineer. I also got the undergraduate certificate of Sun Yat-sen University in last year.
I have seven years of Java work experience now.
I can mastered the mainstream developing technology such as Spring, Hibernate, Spring MVC, Mybatis, I also can use the database like ORACLE/MYSQL; For the front end, jQuery framework such as Easy UI was also involved in my work. I think I'm a good team player and I'm a person of great honesty to others. Also I am a fast learner and able to work under great pressure.
That’s all. Thank you for giving me the chance.

Good afternoon, I am delighted to have this interview opportunity. My name is XXX, you can call me Mike. I’m 30 years old, born in jingzhou city of hubei province.
I graduated from Chongqing Collegeof Electronic Engineering in 2009. I got my bachelor's degree in adult education from South China University of Technology in 2016.My major is computer science and technology.I like programming very much and have 8 years of java experience.I have the ability to develope web apps and back-end services. I also have experience of team management, with 7 persons in my team.
I have mastered mainstream developing technologies such as SSH,SpringMVC, Bootstrap,Easy UI  and JQuery.
I'm a good team player and I'm a person of great honesty to others. I am  also a fast learner and is able to work under great pressure.
Thank you for giving me the chance.

Good afternoon!
It is really my honor to have this opportunity for a interview, 
I hope I can make a good performance today. 
I'm confident that I can succeed. Now I will introduce myself briefly.
I turns 24 this month, born in jiangxi province. I was graduated from East China Jiaotong University
majoring in Software Engineering in 2018.
In 2018. I had  an internship in Shanghai Xinzhi Software for one year and then transferred to full-time work for one year,
mainly engaged in the block chain research. During which I applied the blockchain to the agricultural product traceability project.
Then I changed my jod in order to get more technical promotion.
Since April 2019, I have participated in 3 projects in Shanghai Weiyuan, 
namely Yisun accessories ark, Weiyuan Cloud platform and online exam training.
The accessories cabinet is designed to provide one-stop service for auto accessories from factories to offline stores. 
I am mainly responsible for partners joining in and docking with JINGdong warehouse.
Weiyuan cloud platform is mainly a saas platform for quick deployment of safety production services for enterprise users.
I am mainly responsible for tenant application, organizational structure, document management and development of safety production business.
The online training exam is mainly an online one-stop learning platform for registration.
In which I am responsible for the training and learning, test questions, admission ticket JI examination.
So that's about some of my work experience.

2.常见英文面试问题
1、Do you have an English name?  How to spell it？
2、Can you introduce yourself in 1-2 minutes?  
3、Where is your hometown? Can you try to introduce your family?
4、What’s your hobbies?
&In your daily life, what do you like to do normally?
5、Why do you quit your job? 
I mean why do you change your job.
Why do you leave your last job?
6、Can you give me a summary of your current job? 
7、Can you describe your work experience?  
Can you introduce your project for us? 
    Can you tell me something about your project?
8、Can you try to introduce the most challenging project you have done before?
9、Could you describe how did you solve the problem?
10、Could you describe what did you learn from this project?
11、What’s your career plan?
   I mean what do you want to do in one or two years?
Answer: 
In the short term, I will enhance my backing domain knowledge. I also want to learn one or two work-related skills so that I can perform good in my new job.
  In the long term, i want to be a system architect/system analysis/project manager/engineer Team leader/...
  I like java very much so that I want to make more achievement in this area.
12、What contributions did you make in your last job? 
13、What do you think you are worth of us? 
   I mean what’s your advantage to make us invite you to join my company.
14、How do you lead the team?
   How do you train the new joiner?
15、How do you train up the new staff and make sure their coding quality?
Answer: 
First, I will let them get familiar with the document. 
   Second, I will let them do the unit test first. Also I will review their coding.
   Third, I will do some training to strengthen our team technical skill. At the mean time, I also will build some code specifications.







### Java基本数据类型   

```
byte,short,int,long,float,double,char,boolean
```

### equals与hashcode ==和equals的区别

```
1.equals与hashcode
①第一种 不会创建“类对应的散列表”
	这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。
	在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！
    这种情况下，equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。
②第二种 会创建“类对应的散列表”
	 1)、如果两个对象相等，那么它们的hashCode()值一定相同。这里的相等是指，通过equals()比较两个对象时返回true。
     2)、如果两个对象hashCode()相等，它们并不一定相等。
     因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。
     此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。
2.==和equals的区别
	== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不试同一个对象。
    equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
    情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。
    情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)
```

### int有几个字节？

```
4字节
```

### 一个字节占几位？

```
8位(b)
```

### java多线程有几种创建方式，线程状态有哪些 

```
1.继承Thread类，重写run()方法
2.实现Runnable接口，重写run()方法
3.匿名内部类的形式（本质也是Thread和Runnable的形式）
4.带返回值的线程(实现implements Callable<返回值类型>)
5.Executor，ThreadPoolExecutor

New：新创建的线程，尚未执行；
Runnable：运行中的线程，正在执行run()方法的Java代码；
Blocked：运行中的线程，因为某些操作被阻塞而挂起；
Waiting：运行中的线程，因为某些操作在等待中；
Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；
Terminated：线程已终止，因为run()方法执行完毕。
用一个状态转移图表示如下：

         ┌─────────────┐
         │     New     │
         └─────────────┘
                │
                ▼
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
 ┌─────────────┐ ┌─────────────┐
││  Runnable   │ │   Blocked   ││
 └─────────────┘ └─────────────┘
│┌─────────────┐ ┌─────────────┐│
 │   Waiting   │ │Timed Waiting│
│└─────────────┘ └─────────────┘│
 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
                │
                ▼
         ┌─────────────┐
         │ Terminated  │
         └─────────────┘
当线程启动后，它可以在Runnable、Blocked、Waiting和Timed Waiting这几个状态之间切换，直到最后变成Terminated状态，线程终止。
线程终止的原因有：
线程正常终止：run()方法执行到return语句返回；
线程意外终止：run()方法因为未捕获的异常导致线程终止；
对某个线程的Thread实例调用stop()方法强制终止（强烈不推荐使用）。
一个线程还可以等待另一个线程直到其运行结束。例如，main线程在启动t线程后，可以通过t.join()等待t线程结束后再继续运行：
```

![image-20220216210523572](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220216210523572.png)

### 设计模式的六大设计原则 

#### 单一职责原则的定义（类、方法、接口）

单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。

该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：

1. 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
2. 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。

##### 单一职责原则的优点

单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。

- 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
- 提高类的可读性。复杂性降低，自然其可读性会提高。
- 提高系统的可维护性。可读性提高，那自然更容易维护了。
- 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。

##### 单一职责原则的实现方法

单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。

##### 示例

```java
public interface UserService {
    
    public void login(String username, String password);
    public void register(String email, String username, String password);
    public void logError(String msg);
    public void sendEmail(String email);
    
}
```

```
这段代码很显然存在很大的问题，UserService 既要负责用户的注册和登录，还要负责日志的记录和邮件的发送，并且后者的行为明显区别于前者。
假设我要修改发送邮件的逻辑就得修改这个类，这时候 qa 还得回归登录注册逻辑，这样明显不合理。
```

因此我们需要进行拆分，根据具体的职能可将其具体拆分如下：

**UserService**：只负责登录注册

```java
public interface UserService {

    public void login(String username, String password);
    public void register(String email, String username, String password);

}
```

**LogService ：**`只负责日志`

```java
public interface LogService {

    public void logError(String msg);

}
```

**EmailService**： 只负责发送邮件

```java
public interface EmailService {

    public void sendEmail(String email);

}
这时候，咱们再去回顾前面提到的优点，就能深深体会了。
```

这里只是讲了接口，其实对类也一样，甚至方法也是一样的。

对于类来说，根据类名，确保里面提供的方法都是属于这个类的。

对于方法，不要把不相关的对象实例作为参数传进来。如果你发现某个方法依赖某个不相关的对象，那么这个方法的实现可能就存在问题。

比如 android 中图片下载后显示到 imageView 中，我提供如下的方法：

```
loadImage(String url, ImageView view) {

// 下载图片，展示图片

}
```

对于 loadImage 这个方法，参数 url 是ok 的，但是参数 ImageView 却是不合理的。因为这里做了两个操作，下载图片，展示图片。应该将这个方法在进行拆分：

```java
// 下载图片 
loadImage(String url) {

}
// 显示图片
displayImage(String url, ImageView view) {

// 调用 getBitmap (url)  获取图片
// 获取图片后将其设置到 view 中。

}

// 根据 url 获取图片， 
getBitmap(String url) {

}
```

这样整个逻辑就很清晰。后续需要修改下载逻辑，也不会影响到展示逻辑。当然其实还有个问题是，这两个方法要不要放在一个类里面？

 

#### 开闭原则

开闭原则的实现方法：可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

##### 示例

```java
// 矩形
public class Rectangle {

    public double getWidth() {
        return width;
    }
    
    public double getHeight() {
        return height;
    }

} 
```

需要计算矩形的面积

```java
// 面积计算器
public class AreaCalculator {

    public double area(Rectangle shape){
        return shape.getWidth() * shape.getHeight();
    }
}
```

假设这时候，又多了一个圆形类

```java
// 圆形
public class Circular {

    public double getRadius(){
        return radius;
    }
}
```

同样也需要计算他的面积，这时候就会变成下面这样子：

```java
public class AreaCalculator {

    public double area(Object shape){
        if(shape instanceof Rectangle) {
            Rectangle rectangle = (Rectangle) shape;
            return rectangle.getWidth() * rectangle.getHeight();
        } else if (shape instanceof Circular) {
            Circular circular = (Circular) shape;
            return circular.getRadius() * circular.getRadius() * Math.PI;
        } else {
            throw new RuntimeException("There is no such type.");
        }
    }
}
```

这么更改完成，完全没有问题。但是在真实的生产环境中，情况更为复杂，更改涉及的部分较多，那样就可能导致牵一发动全身。并且，以前编写的经过测试的一些功能需要重新测试，甚至导致某些功能不可用。

改进版，把计算面积这个公有逻辑变成一个接口：

```java
public interface Shape {

    public double getArea();

}
 
public class Rectangle implements Shape{

    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    public double getArea() {
        return getWidth() * getHeight();
    }
    
}
```

这样，当需求变更，需要计算圆形面积的时候，我们只需创建一个圆形的类，并实现 Shape 接口即可:

```java
public class Circular implements Shape {

    public double getRadius(){
        return radius;
    }

    public double getArea() {
        return getRadius() * getRadius() * Math.PI;
    }
}
```

计算三角形面积、四边形面积... 的时候，我们只需让它们去实现 Shape 接口即可，无需修改源代码。

 

#### 里氏替换原则

里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。

##### 里氏替换原则的作用

里氏替换原则的主要作用如下。

1. 里氏替换原则是实现开闭原则的重要方式之一。
2. 它克服了继承中重写父类造成的可复用性变差的缺点。
3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
4. 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。

##### 里氏替换原则的实现方法（继承）

里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

根据上述理解，对里氏替换原则的定义可以总结如下：

- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
- 子类中可以增加自己特有的方法
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
- 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等

通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。

如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。

这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。

关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。

对于正方形和长方形最好的做法是再添加一个父类，他们同时继承自这个父类。

 

#### 依赖倒置（抽线细节）

依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。

由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。

使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。

##### 依赖、倒置原则的作用

依赖倒置原则的主要作用如下。

- 依赖倒置原则可以降低类间的耦合性。
- 依赖倒置原则可以提高系统的稳定性。
- 依赖倒置原则可以减少并行开发引起的风险。
- 依赖倒置原则可以提高代码的可读性和可维护性。

##### 依赖倒置原则的实现方法

依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。

1. 每个类尽量提供接口或抽象类，或者两者都具备。
2. 变量的声明类型尽量是接口或者是抽象类。
3. 任何类都不应该从具体类派生。
4. 使用继承时尽量遵循里氏替换原则。

依赖倒置原则在“顾客购物程序”中的应用。

分析：本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物

```
 class Customer {
    public void shopping(ShaoguanShop shop) {
        //购物
        System.out.println（shop.sell());
    }
}
```

但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下：

```
class Customer {
    public void shopping(WuyuanShop shop) {
        //购物
        System.out.println(shop.sell());
    }
}
```

顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。

存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。

解决方法是：定义“婺源网店”和“韶关网店”的共同接口 Shop，顾客类面向该接口编程，其代码修改如下：

```
class Customer {
    public void shopping(Shop shop) {
        //购物
        System.out.println(shop.sell());
    }
}

class Customer {
    public void shopping(Shop shop) {
        //购物
        System.out.println(shop.sell());
    }
}
```

这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类如下图所示：


![顾客购物程序的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113131610L7.gif)
程序代码如下：

```
package principle;
public class DIPtest
{
    public static void main(String[] args)
    {
        Customer wang=new Customer();
        System.out.println("顾客购买以下商品："); 
        wang.shopping(new ShaoguanShop()); 
        wang.shopping(new WuyuanShop());
    }
}
//商店
interface Shop
{
    public String sell(); //卖
}
//韶关网店
class ShaoguanShop implements Shop
{
    public String sell()
    {
        return "韶关土特产：香菇、木耳……"; 
    } 
}
//婺源网店
class WuyuanShop implements Shop
{
    public String sell()
    {
        return "婺源土特产：绿茶、酒糟鱼……"; 
    }
} 
//顾客
class Customer
{
    public void shopping(Shop shop)
    {
        //购物
        System.out.println(shop.sell()); 
    }
} 
```

程序的运行结果如下：

```
顾客购买以下商品：
韶关土特产：香菇、木耳……
婺源土特产：绿茶、酒糟鱼……
```

#### 接口隔离原则（接口）

接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。

2002 年罗伯特·C.马丁给“接口隔离原则”的定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。

以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：

- 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
- 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

##### 接口隔离原则的优点

接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。

1. 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
2. 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
3. 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
4. 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
5. 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

##### 接口隔离原则的实现方法

在具体应用接口隔离原则时，应该根据以下几个规则来衡量。

- 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
- 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
- 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
- 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

对于接口隔离，大家还是可以参考单一职责提到的示例：

```
public interface UserService {
    
    public void login(String username, String password);
    public void register(String email, String username, String password);
    public void logError(String msg);
    public void sendEmail(String email);
    
} 
```

这时候，应该就能理解拆分的好处了。

#### 迪米特法则 (类与类之间的关系)

迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知。

迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。

##### 迪米特法则的优点

迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。

1. 降低了类之间的耦合度，提高了模块的相对独立性。
2. 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。

但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。

##### 迪米特法则的实现方法

从迪米特法则的定义和特点可知，它强调以下两点：

1. 从依赖者的角度来说，只依赖应该依赖的对象。
2. 从被依赖者的角度说，只暴露应该暴露的方法。

所以，在运用迪米特法则时要注意以下 6 点。

1. 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
2. 在类的结构设计上，尽量降低类成员的访问权限。
3. 在类的设计上，优先考虑将一个类设置成不变类。
4. 在对其他类的引用上，将引用其他对象的次数降到最低。
5. 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
6. 谨慎使用序列化（Serializable）功能

明星与经纪人的关系实例。

分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则，其类图如下图所示。


![明星与经纪人的关系图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113152Q5W1.gif)
代码如下： 

```java
package principle;
public class LoDtest
{
    public static void main(String[] args)
    {
        Agent agent=new Agent();
        agent.setStar(new Star("林心如"));
        agent.setFans(new Fans("粉丝韩丞"));
        agent.setCompany(new Company("中国传媒有限公司"));
        agent.meeting();
        agent.business();
    }
}
//经纪人
class Agent
{
    private Star myStar;
    private Fans myFans;
    private Company myCompany;
    public void setStar(Star myStar)
    {
        this.myStar=myStar;
    }
    public void setFans(Fans myFans)
    {
        this.myFans=myFans;
    }
    public void setCompany(Company myCompany)
    {
        this.myCompany=myCompany;
    }
    public void meeting()
    {
        System.out.println(myFans.getName()+"与明星"+myStar.getName()+"见面了。");
    }
    public void business()
    {
        System.out.println(myCompany.getName()+"与明星"+myStar.getName()+"洽淡业务。");
    }
}
//明星
class Star
{
    private String name;
    Star(String name)
    {
        this.name=name;
    }
    public String getName()
    {
        return name;
    }
}
//粉丝
class Fans
{
    private String name;
    Fans(String name)
    {
        this.name=name;
    }
    public String getName()
    {
        return name;
    }
}
//媒体公司
class Company
{
    private String name;
    Company(String name)
    {
        this.name=name;
    }
    public String getName()
    {
        return name;
    }
}
```

程序的运行结果如下：

粉丝韩丞与明星林心如见面了。
中国传媒有限公司与明星林心如洽淡业务。

### 什么是数据库连接池？

```
官方：数据库连接池（Connection pooling）是程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由程序动态地对池中的连接进行申请，使用，释放。
个人理解：创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。所以，在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，还更加安全可靠
```

### 当数据库重启之后，数据库连接池里的连接对象还可以使用吗？

```
不可用，他会进行重连操作
　传统统链接:一般来说，Java应用程序访问数据库的过程是：
　　①装载数据库驱动程序；
　　②通过JDBC建立数据库连接；
　　③访问数据库，执行SQL语句；
　　④断开数据库连接。
使用了数据库连接池的机制：
（1） 程序初始化时创建连接池
（2） 使用时向连接池申请可用连接
（3） 使用完毕，将连接返还给连接池
（4） 程序退出时，断开所有连接，并释放资源
```












什么是函数式接口

异常：
异常的继承结构是什么样？

Exception的父类是什么？

Exception和error的区别是什么？

程序没有catch住的异常会被谁catch住？

程序没有catch住的异常，怎么处理，handle怎么实现？

算法：
什么是最优二叉树？
怎么实现最优二叉树？

数据库：
并发怎么控制？

### 类加载的机制？

```
1.装载 -- 双亲委派机制（Bootstrap,Extension,app,用户自定义）
(1)通过一个类的全限定名获取定义此类的二进制字节流 
(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 
(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口
2.链接（验证，准备，解析）
(1)验证：保证被加载类的正确性 文件格式验证/元数据验证/字节码验证/符号引用验证 
(2)准备：为类的静态变量分配内存，并将其初始化为默认值 
(3)解析：把类中的符号引用转换为直接引用
3.初始化
对类的静态变量，静态代码块执行初始化操作
```

### 类的生命周期？

```
一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备、解析统称为连接。
四、使用
对象的创建：
对象创建的并发问题：
虚拟机是否使用 TLAB，可以通过 -XX:+/-UseTLAB 参数来设定；
五、卸载
由java虚拟机自带的加载器加载的类，在虚拟机的生命周期中，始终不会被卸载 ，因为java虚拟机本身会一直使用用这些类加载器，而这些类加载器会一直引用它们加载的类的Class对象，因此这些类不会被卸载。
由用户自定义的类加载器加载的类是可以被卸载的。一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。
```

### 什么是final？什么是final类？

```
Java中，final关键字可以用来修饰类（不可被继承）、方法（不能再子类中覆盖重写）和变量（不能修改）（包括成员变量和局部变量）重载是多个同名方法（参数类型，个数，顺序），重写是子类重写父类同名方法
1.修饰类
　　当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。
　　在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。
　　2.修饰方法
　　因此，如果只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。
　　注：类的private方法会隐式地被指定为final方法。
　　3.修饰变量
　　修饰变量是final用得最多的地方，也是本文接下来要重点阐述的内容。
　　对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
```

有没有final构造方法？



讲一下String，string为什么设计为final类

什么是abstract？

abstract可以修饰什么？

什么是函数方法？

什么是泛型？
谈谈你对泛型的理解

多线程：
多线程的状态有哪些？

解释下什么是Join？

什么是线程同步？

怎么实现线程同步？

Synchronized加在方法上和加在静态方法上的区别？


设计模式：
设计模式有哪些原则？

什么是开闭原则？
什么是开，什么是闭？

什么是包装模式？

平时接触过哪些设计模式？
重写object对象的equasl方法时，通常还要重写哪个方法
后台server怎么推送消息给H5页面

1、Eurrake保证了cap中的哪些特性

2、Explain查看sql执行计划

3、ReentrantLock和Synchronized区别

4、线程池参数怎么设置

5、线程池如果没有使用，核心线程是否会消失

6、Jvm可达性分析，哪个对象可作为root

7、JMM相关知识

8、线程私有区

9、虚拟机栈知识点

10、Spring循环依赖

11、Spring el表达式

12、分布式框架有哪些

13、幂等性问题

14、Quartz定时器怎么实现

15、RabbitMQ相关知识

16、Mybaits和数据库连接池相关知识

17、组合索引会出现什么问题

视频一面：

1、项目介绍以及具体实现

2、项目中有哪些难点以及怎么遇到的问题

3、单体应用和微服务的区别

4、Timer有哪些重要的API以及这些API是怎么实现的

5、Netty相关知识

6、Java反射相关知识

7、HashMap底层实现

视频二面：

1、ArrayList和LinkedList区别（底层实现区别）

2、InputStream和reader区别

面试回访:
1.介绍一下你的技术栈.
2.介绍一下你最近的项目.
3.在项目中你遇到过什么问题.
4.在项目中你如何与别人沟通.
5.你认为你的技术栈你偏向前端还是后端.
6.js问题.js中的call和flush有什么区别.
7.react字父类继承参数如何传递.
8.项目中有写过复杂的css样式吗?
9.查出表中语文成绩第二的人.(语言描述)
10.查出表中语文成绩并列前三的人.(语言描述)
11.项目中有用过多线程吗?如何优化.
12.你觉的你的英文水平怎么样?

jdk反射机制

```

```

wangzhen-java-庾俊雄项目组面试：

1、讲一下springBoot常用的注解

2、object的方法有哪些

3、用过线程池吗

5、redis的雪崩是什么，如何处理

6、sql的优化


第二轮面试：

1、int范围，怎么计算的

2、讲一下hashcode

3、arraylist和linkedlist的区别


1 合并两个链表，将两个链表合并成一个有序链表


2 排序算法有几种 复杂度怎么样

3 谈谈你对算法的认识

2、常用的集合有哪些？简单说下

3、new HashTable()的创建过程

4、怎么处理数据库中查回的10000条数据？

5、ArrayList怎么删除元素？

6、create Table user之后，user表中只有id列，那么可以插入重复id吗？
 写一个delete语句，删除表中重复元素

7、运行时异常和非运行时异常的区别？

nacos zookeeper dubbo 多线程

登陆问的多