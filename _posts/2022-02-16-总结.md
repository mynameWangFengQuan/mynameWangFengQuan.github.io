面试准备

### 一、英文自我介绍准备

1.自我介绍范文（仅供参考）
Good morning/afternoon/evening, my name is XXX. I’m 24 years old. I came from XXX city of XXX province.
I graduated from shandong University of XXX University in 2020. My major is computer science and technology. I have large enthusiasm in programming. I learned very hard and learned Java by myself during the college.
After graduate, I found a job in a  XXX IT company. I have worked in this company for one years. I can mastered the mainstream developing technology such as Spring, SpringBoot,SpringClould, Spring MVC, Mybatis, I also can use the database like MYSQL; For the front end, jQuery framework such as Easy UI and Bootstrap was also involved in my work.
Now I’d like to find a job in ShangHai,which one I want to improve my English and technique. I’m very interested in HSBC’s opportunity and hope to join your team if possible. Thanks for your listening.

### Java基本数据类型   

```
byte,short,int,long,float,double,char,boolean
```

### equals与hashcode ==和equals的区别

```
1.equals与hashcode
①第一种 不会创建“类对应的散列表”
	这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。
	在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！
    这种情况下，equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。
②第二种 会创建“类对应的散列表”
	 1)、如果两个对象相等，那么它们的hashCode()值一定相同。这里的相等是指，通过equals()比较两个对象时返回true。
     2)、如果两个对象hashCode()相等，它们并不一定相等。
     因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。
     此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。
2.==和equals的区别
	== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不试同一个对象。
    equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
    情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。
    情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)
```

### int有几个字节？

```
4字节
```

### 一个字节占几位？

```
8位(b)
```

### java多线程有几种创建方式，线程状态有哪些 

```
1.继承Thread类，重写run()方法
2.实现Runnable接口，重写run()方法
3.匿名内部类的形式（本质也是Thread和Runnable的形式）
4.带返回值的线程(实现implements Callable<返回值类型>)
5.Executor，ThreadPoolExecutor

New：新创建的线程，尚未执行；
Runnable：运行中的线程，正在执行run()方法的Java代码；
Blocked：运行中的线程，因为某些操作被阻塞而挂起；
Waiting：运行中的线程，因为某些操作在等待中；
Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；
Terminated：线程已终止，因为run()方法执行完毕。
用一个状态转移图表示如下：

         ┌─────────────┐
         │     New     │
         └─────────────┘
                │
                ▼
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
 ┌─────────────┐ ┌─────────────┐
││  Runnable   │ │   Blocked   ││
 └─────────────┘ └─────────────┘
│┌─────────────┐ ┌─────────────┐│
 │   Waiting   │ │Timed Waiting│
│└─────────────┘ └─────────────┘│
 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
                │
                ▼
         ┌─────────────┐
         │ Terminated  │
         └─────────────┘
当线程启动后，它可以在Runnable、Blocked、Waiting和Timed Waiting这几个状态之间切换，直到最后变成Terminated状态，线程终止。
线程终止的原因有：
线程正常终止：run()方法执行到return语句返回；
线程意外终止：run()方法因为未捕获的异常导致线程终止；
对某个线程的Thread实例调用stop()方法强制终止（强烈不推荐使用）。
一个线程还可以等待另一个线程直到其运行结束。例如，main线程在启动t线程后，可以通过t.join()等待t线程结束后再继续运行：
```

![image-20220216210523572](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220216210523572.png)

### 设计模式的六大设计原则 

#### 单一职责原则的定义（类、方法、接口）

单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。

该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：

1. 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
2. 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。

##### 单一职责原则的优点

单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。

- 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
- 提高类的可读性。复杂性降低，自然其可读性会提高。
- 提高系统的可维护性。可读性提高，那自然更容易维护了。
- 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。

##### 单一职责原则的实现方法

单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。

##### 示例

```java
public interface UserService {
    
    public void login(String username, String password);
    public void register(String email, String username, String password);
    public void logError(String msg);
    public void sendEmail(String email);
    
}
```

```
这段代码很显然存在很大的问题，UserService 既要负责用户的注册和登录，还要负责日志的记录和邮件的发送，并且后者的行为明显区别于前者。
假设我要修改发送邮件的逻辑就得修改这个类，这时候 qa 还得回归登录注册逻辑，这样明显不合理。
```

因此我们需要进行拆分，根据具体的职能可将其具体拆分如下：

**UserService**：只负责登录注册

```java
public interface UserService {

    public void login(String username, String password);
    public void register(String email, String username, String password);

}
```

**LogService ：**`只负责日志`

```java
public interface LogService {

    public void logError(String msg);

}
```

**EmailService**： 只负责发送邮件

```java
public interface EmailService {

    public void sendEmail(String email);

}
这时候，咱们再去回顾前面提到的优点，就能深深体会了。
```

这里只是讲了接口，其实对类也一样，甚至方法也是一样的。

对于类来说，根据类名，确保里面提供的方法都是属于这个类的。

对于方法，不要把不相关的对象实例作为参数传进来。如果你发现某个方法依赖某个不相关的对象，那么这个方法的实现可能就存在问题。

比如 android 中图片下载后显示到 imageView 中，我提供如下的方法：

```
loadImage(String url, ImageView view) {

// 下载图片，展示图片

}
```

对于 loadImage 这个方法，参数 url 是ok 的，但是参数 ImageView 却是不合理的。因为这里做了两个操作，下载图片，展示图片。应该将这个方法在进行拆分：

```java
// 下载图片 
loadImage(String url) {

}
// 显示图片
displayImage(String url, ImageView view) {

// 调用 getBitmap (url)  获取图片
// 获取图片后将其设置到 view 中。

}

// 根据 url 获取图片， 
getBitmap(String url) {

}
```

这样整个逻辑就很清晰。后续需要修改下载逻辑，也不会影响到展示逻辑。当然其实还有个问题是，这两个方法要不要放在一个类里面？

#### 开闭原则

开闭原则的实现方法：可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

##### 示例

```java
// 矩形
public class Rectangle {

    public double getWidth() {
        return width;
    }
    
    public double getHeight() {
        return height;
    }

} 
```

需要计算矩形的面积

```java
// 面积计算器
public class AreaCalculator {

    public double area(Rectangle shape){
        return shape.getWidth() * shape.getHeight();
    }
}
```

假设这时候，又多了一个圆形类

```java
// 圆形
public class Circular {

    public double getRadius(){
        return radius;
    }
}
```

同样也需要计算他的面积，这时候就会变成下面这样子：

```java
public class AreaCalculator {

    public double area(Object shape){
        if(shape instanceof Rectangle) {
            Rectangle rectangle = (Rectangle) shape;
            return rectangle.getWidth() * rectangle.getHeight();
        } else if (shape instanceof Circular) {
            Circular circular = (Circular) shape;
            return circular.getRadius() * circular.getRadius() * Math.PI;
        } else {
            throw new RuntimeException("There is no such type.");
        }
    }
}
```

这么更改完成，完全没有问题。但是在真实的生产环境中，情况更为复杂，更改涉及的部分较多，那样就可能导致牵一发动全身。并且，以前编写的经过测试的一些功能需要重新测试，甚至导致某些功能不可用。

改进版，把计算面积这个公有逻辑变成一个接口：

```java
public interface Shape {

    public double getArea();

}
 
public class Rectangle implements Shape{

    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    public double getArea() {
        return getWidth() * getHeight();
    }
    
}
```

这样，当需求变更，需要计算圆形面积的时候，我们只需创建一个圆形的类，并实现 Shape 接口即可:

```java
public class Circular implements Shape {

    public double getRadius(){
        return radius;
    }

    public double getArea() {
        return getRadius() * getRadius() * Math.PI;
    }
}
```

计算三角形面积、四边形面积... 的时候，我们只需让它们去实现 Shape 接口即可，无需修改源代码。

#### 里氏替换原则

里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。

##### 里氏替换原则的作用

里氏替换原则的主要作用如下。

1. 里氏替换原则是实现开闭原则的重要方式之一。
2. 它克服了继承中重写父类造成的可复用性变差的缺点。
3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
4. 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。

##### 里氏替换原则的实现方法（继承）

里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

根据上述理解，对里氏替换原则的定义可以总结如下：

- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
- 子类中可以增加自己特有的方法
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
- 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等

通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。

如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。

这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。

关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。

对于正方形和长方形最好的做法是再添加一个父类，他们同时继承自这个父类。

#### 依赖倒置（抽线细节）

依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。

由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。

使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。

##### 依赖、倒置原则的作用

依赖倒置原则的主要作用如下。

- 依赖倒置原则可以降低类间的耦合性。
- 依赖倒置原则可以提高系统的稳定性。
- 依赖倒置原则可以减少并行开发引起的风险。
- 依赖倒置原则可以提高代码的可读性和可维护性。

##### 依赖倒置原则的实现方法

依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。

1. 每个类尽量提供接口或抽象类，或者两者都具备。
2. 变量的声明类型尽量是接口或者是抽象类。
3. 任何类都不应该从具体类派生。
4. 使用继承时尽量遵循里氏替换原则。

依赖倒置原则在“顾客购物程序”中的应用。

分析：本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物

```
 class Customer {
    public void shopping(ShaoguanShop shop) {
        //购物
        System.out.println（shop.sell());
    }
}
```

但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下：

```
class Customer {
    public void shopping(WuyuanShop shop) {
        //购物
        System.out.println(shop.sell());
    }
}
```

顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。

存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。

解决方法是：定义“婺源网店”和“韶关网店”的共同接口 Shop，顾客类面向该接口编程，其代码修改如下：

```
class Customer {
    public void shopping(Shop shop) {
        //购物
        System.out.println(shop.sell());
    }
}

class Customer {
    public void shopping(Shop shop) {
        //购物
        System.out.println(shop.sell());
    }
}
```

这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类如下图所示：


![顾客购物程序的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113131610L7.gif)
程序代码如下：

```
package principle;
public class DIPtest
{
    public static void main(String[] args)
    {
        Customer wang=new Customer();
        System.out.println("顾客购买以下商品："); 
        wang.shopping(new ShaoguanShop()); 
        wang.shopping(new WuyuanShop());
    }
}
//商店
interface Shop
{
    public String sell(); //卖
}
//韶关网店
class ShaoguanShop implements Shop
{
    public String sell()
    {
        return "韶关土特产：香菇、木耳……"; 
    } 
}
//婺源网店
class WuyuanShop implements Shop
{
    public String sell()
    {
        return "婺源土特产：绿茶、酒糟鱼……"; 
    }
} 
//顾客
class Customer
{
    public void shopping(Shop shop)
    {
        //购物
        System.out.println(shop.sell()); 
    }
} 
```

程序的运行结果如下：

```
顾客购买以下商品：
韶关土特产：香菇、木耳……
婺源土特产：绿茶、酒糟鱼……
```

#### 接口隔离原则（接口）

接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。

2002 年罗伯特·C.马丁给“接口隔离原则”的定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。

以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：

- 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
- 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

##### 接口隔离原则的优点

接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。

1. 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
2. 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
3. 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
4. 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
5. 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

##### 接口隔离原则的实现方法

在具体应用接口隔离原则时，应该根据以下几个规则来衡量。

- 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
- 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
- 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
- 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

对于接口隔离，大家还是可以参考单一职责提到的示例：

```
public interface UserService {
    
    public void login(String username, String password);
    public void register(String email, String username, String password);
    public void logError(String msg);
    public void sendEmail(String email);
    
} 
```

这时候，应该就能理解拆分的好处了。

#### 迪米特法则 (类与类之间的关系)

迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知。

迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。

##### 迪米特法则的优点

迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。

1. 降低了类之间的耦合度，提高了模块的相对独立性。
2. 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。

但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。

##### 迪米特法则的实现方法

从迪米特法则的定义和特点可知，它强调以下两点：

1. 从依赖者的角度来说，只依赖应该依赖的对象。
2. 从被依赖者的角度说，只暴露应该暴露的方法。

所以，在运用迪米特法则时要注意以下 6 点。

1. 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
2. 在类的结构设计上，尽量降低类成员的访问权限。
3. 在类的设计上，优先考虑将一个类设置成不变类。
4. 在对其他类的引用上，将引用其他对象的次数降到最低。
5. 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
6. 谨慎使用序列化（Serializable）功能

明星与经纪人的关系实例。

分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则，其类图如下图所示。


![明星与经纪人的关系图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113152Q5W1.gif)
代码如下： 

```java
package principle;
public class LoDtest
{
    public static void main(String[] args)
    {
        Agent agent=new Agent();
        agent.setStar(new Star("林心如"));
        agent.setFans(new Fans("粉丝韩丞"));
        agent.setCompany(new Company("中国传媒有限公司"));
        agent.meeting();
        agent.business();
    }
}
//经纪人
class Agent
{
    private Star myStar;
    private Fans myFans;
    private Company myCompany;
    public void setStar(Star myStar)
    {
        this.myStar=myStar;
    }
    public void setFans(Fans myFans)
    {
        this.myFans=myFans;
    }
    public void setCompany(Company myCompany)
    {
        this.myCompany=myCompany;
    }
    public void meeting()
    {
        System.out.println(myFans.getName()+"与明星"+myStar.getName()+"见面了。");
    }
    public void business()
    {
        System.out.println(myCompany.getName()+"与明星"+myStar.getName()+"洽淡业务。");
    }
}
//明星
class Star
{
    private String name;
    Star(String name)
    {
        this.name=name;
    }
    public String getName()
    {
        return name;
    }
}
//粉丝
class Fans
{
    private String name;
    Fans(String name)
    {
        this.name=name;
    }
    public String getName()
    {
        return name;
    }
}
//媒体公司
class Company
{
    private String name;
    Company(String name)
    {
        this.name=name;
    }
    public String getName()
    {
        return name;
    }
}
```

程序的运行结果如下：

粉丝韩丞与明星林心如见面了。
中国传媒有限公司与明星林心如洽淡业务。

### 什么是数据库连接池？

```
官方：数据库连接池（Connection pooling）是程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由程序动态地对池中的连接进行申请，使用，释放。
个人理解：创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。所以，在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，还更加安全可靠
```

### 当数据库重启之后，数据库连接池里的连接对象还可以使用吗？

```
不可用，他会进行重连操作
　传统统链接:一般来说，Java应用程序访问数据库的过程是：
　　①装载数据库驱动程序；
　　②通过JDBC建立数据库连接；
　　③访问数据库，执行SQL语句；
　　④断开数据库连接。
使用了数据库连接池的机制：
（1） 程序初始化时创建连接池
（2） 使用时向连接池申请可用连接
（3） 使用完毕，将连接返还给连接池
（4） 程序退出时，断开所有连接，并释放资源
```

### 异常：

> https://www.cnblogs.com/cxuanBlog/p/12659578.html

### 异常的继承结构是什么样？Exception的父类是什么？

![img](https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200408140301956-1960607146.png)

### Exception和error的区别是什么？

```
Error 是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。这些错误是不可检查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况，比如 OutOfMemoryError 和 StackOverflowError
Exception 的父类是 Throwable，并且 Exception 有两种异常，一种是 RuntimeException ；一种是 CheckedException，这两种异常都应该去捕获。
```

### 程序没有catch住的异常会被谁catch住？

```
当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try ... catch被捕获为止
```

### 程序没有catch住的异常，怎么处理，handle怎么实现？

#### UncaughtExceptionHandler 是什么

- 它是线程遇到未捕获异常的一个处理者接口
- 它包含一个方法`void uncaughtException(Thread t, Throwable e);` 用来处理接收处理异常发生后的操作，比如收集崩溃信息并上报等
- 可以通过 实例方法 `Thread.setUncaughtExceptionHandler` 为某一个Thread实例设置未捕获异常处理者
- 也可以通过 静态方法 `Thread.setDefaultUncaughtExceptionHandler` 设置所有Thread实例的未捕获异常处理者

#### ThreadGroup 是什么

- ThreadGroup 是线程的集合
- ThreadGroup 也可以包含子ThreadGroup
- 除了初始的ThreadGroup 之外，每个ThreadGroup都有一个父 ThreadGroup
- ThreadGroup 自身实现了Thread.UncaughtExceptionHandler，用来相应处理其内部的线程和ThreadGroup发生未捕获异常。

#### 未捕获异常处理者 设置指南

![how to set uncaught exception handler](https://asset.droidyue.com/image/2019_first_half/how_to_set_uncaught_exceptions.png)

#### 线程发生了未捕获异常，JVM怎么处理

##### 分发Throwable实例

当线程A中出现了未捕获异常时，JVM会调用线程A的`dispatchUncaughtException(Throwable)`方法

```java
private void dispatchUncaughtException(Throwable e) {   							getUncaughtExceptionHandler().uncaughtException(this, e); 
} 
```

##### 获取未捕获异常处理者

- 每个线程会有一个变量(uncaughtExceptionHandler)来保存未捕获异常的处理者
- 在线程需要确定Throwable分发目标的处理者时，优先获取当前线程中uncaughtExceptionHandler变量
- 如果出问题线程的uncaughtExceptionHandler为null（即没有显式设置异常处理者），则使用自己所在的ThreadGroup来作为未捕获异常处理者。

```java
public UncaughtExceptionHandler getUncaughtExceptionHandler() {    
    return uncaughtExceptionHandler != null ? uncaughtExceptionHandler : group; 
} 
```

##### 如果Throwable分发给ThreadGroup

- ThreadGroup会尝试转给它的父ThreadGroup（如果存在的话）
- 如果上面没有找到对应的ThreadGroup，则尝试获取`Thread.getDefaultUncaughtExceptionHandler()`并分发

```java
 public void uncaughtException(Thread t, Throwable e) {        
    if (parent != null) {            
        parent.uncaughtException(t, e);        
    } else {            
        Thread.UncaughtExceptionHandler ueh = Thread.getDefaultUncaughtExceptionHandler();            
        if (ueh != null) {                
            ueh.uncaughtException(t, e);            
        } else if (!(e instanceof ThreadDeath)) {         									 System.err.print("Exception in thread \"" + t.getName() + "\" ");                	  e.printStackTrace(System.err);            
        }        
    }    
 } 
```

##### 初始的ThreadGroup是什么

上面提到了初始的ThreadGroup没有父ThreadGroup，是主线程所在的ThreadGroup么？

初始的ThreadGroup是一个叫做system的ThreadGroup，而不是main ThreadGroup

##### setDefaultUncaughtExceptionHandler 设置的一定会被调用到么

这其实是一个很好的问题，答案是不一定会被调用，因为可能存在以下的情况

- 出问题的线程设置了对应的UncaughtExcpetionHandler，优先响应分发到这个Handler
- 出问题的线程所在的ThreadGroup包括其祖先ThreadGroup 重写了uncaughtException 也可能造成线程默认的Handler无法被调用
- 出问题的线程重写了dispatchUncaughtException 可能性较小
- 出问题的线程重写了getUncaughtExceptionHandler 可能性较小

### 7、运行时异常和非运行时异常的区别？

```markdown
(1)运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。
当出现RuntimeException的时候，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。比如：我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。 
出现运行时异常后，如果没有捕获处理这个异常（即没有catch），系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了。运行时异常是Exception的子类，也有一般异常的特点，是可以被catch块处理的。只不过往往我们不对他处理罢了。也就是说，你如果不对运行时异常进行处理，那么出现运行时异常之后，`要么是线程中止，要么是主程序终止`。 
如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。
(2)非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。
```

### 类加载的机制？

```
1.装载 -- 双亲委派机制（Bootstrap,Extension,app,用户自定义）
(1)通过一个类的全限定名获取定义此类的二进制字节流 
(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 
(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口
2.链接（验证，准备，解析）
(1)验证：保证被加载类的正确性 文件格式验证/元数据验证/字节码验证/符号引用验证 
(2)准备：为类的静态变量分配内存，并将其初始化为默认值 
(3)解析：把类中的符号引用转换为直接引用
3.初始化
对类的静态变量，静态代码块执行初始化操作
```

### 类的生命周期？

```
一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备、解析统称为连接。
四、使用
对象的创建：
对象创建的并发问题：
虚拟机是否使用 TLAB，可以通过 -XX:+/-UseTLAB 参数来设定；
五、卸载
由java虚拟机自带的加载器加载的类，在虚拟机的生命周期中，始终不会被卸载 ，因为java虚拟机本身会一直使用用这些类加载器，而这些类加载器会一直引用它们加载的类的Class对象，因此这些类不会被卸载。
由用户自定义的类加载器加载的类是可以被卸载的。一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。
```

### 什么是final？什么是final类？

```
Java中，final关键字可以用来修饰类（不可被继承）、方法（不能再子类中覆盖重写）和变量（不能修改）（包括成员变量和局部变量）重载是多个同名方法（参数类型，个数，顺序），重写是子类重写父类同名方法
1.修饰类
　　当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。
　　在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。
　　2.修饰方法
　　因此，如果只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。
　　注：类的private方法会隐式地被指定为final方法。
　　3.修饰变量
　　修饰变量是final用得最多的地方，对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
final修饰的变量，无论是类属性、对象属性、形参还是局部变量，都需要进行初始化操作。
```

### 有没有final构造方法？

```
final不能修饰构造方法
构造方法不会被子类继承，final修饰方法就是为了不被重写，所以构造方法没必要加上final修饰
```

##### 被final修饰的变量：三种赋值方式

1. 在定义时直接赋值。
2. 声明时不赋值，在constructor中赋值（最常用的方式）
3. 声明时不赋值，在构造代码块中赋值

>  如果一个非final成员变量在定义的时候没有赋值，那么它只可能在构造函数里被赋值了（不考虑构造代码块的情况）    这个`特性`在JDK以及Spring中都有大量的应用 

```javascript
private final int finalVal = 10;
 private final int finalVal;
    Demo (int val){
        this.finalVal = val;
    }
 private final int finalVal;
    {
        this.finalVal = 10;
    }
```

备注：在看Spring源码的时候，我们会经常看到它定义的final变量，然后对外提供构造函数给与赋值的设计模式。

>  我们得出结论：当你发现一个类的变量被final修饰但没被赋值，那么可以判断出它肯定会在构造函数里被赋值。（因为倘若是set方法赋值，现在是不安全的，因为set方法可以被调用多次，而final变量只能被赋值一次） 

##### 被final static修饰的变量：两种赋值方式

1. 在定义时直接赋值.
2. 在静态代码块里赋值

##### 最后

final变量会经过JVM进行优化处理，所以平时使用过程中建议使用final变量。但更建议读者先重点了解下final变量在JVM中的内存结构后，再频繁使用为佳

### 讲一下String，string为什么设计为final类

**1.为了实现字符串池**

**2.为了线程安全**

**3.为了实现String可以创建HashCode不可变性**

在了解final的用途后，在看String为什么要被final修饰：主要是为了”安全性“和”效率“的缘故。

查看JDK String的源码

![img](https:////upload-images.jianshu.io/upload_images/11805791-f406bc7c4fba3865.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)

final修饰的String，代表了String的不可继承性，final修饰的char[]代表了被存储的数据不可更改性。但是：虽然final代表了不可变，但仅仅是引用地址不可变，并不代表了数组本身不会变,请看下面图片。

![img](https:////upload-images.jianshu.io/upload_images/11805791-9c6c533a20d89665.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)

 final也可以将数组本身改变的，这个时候，起作用的还有**private**，正是因为两者保证了String的不可变性。

 那么为什么保证String不可变呢,因为**只有当字符串是不可变的，字符串池才有可能实现**。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。

------

如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。

------

 因为字符串是不可变的，所以**是多线程安全的**，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。

-----

因为字符串是不可变的，所以在它创建的时候**HashCode**就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。

### 什么是abstract？

- 1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。

- 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

- 3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。

- 4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。

- 5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

```java
1、概述
（1）只给出方法定义而不具体实现的方法被称为抽象方法，抽象方法是没有方法体的，在代码的表达上就是没有“{}”。使用 abstract 修饰符来表示抽象方法和抽象类。
（2）abstract修饰符表示所修饰的类没有完全实现，还不能实例化。如果在类的方法声明中使用abstract修饰符，表明该方法是一个抽象方法，它需要在子类实现。如果一个类包含抽象方法，则这个类也是抽象类，必须使用abstract修饰符，并且不能实例化。
（3）注意，抽象类除了包含抽象方法外，还可以包含具体的变量和具体的方法。类即使不包含抽象方法，也可以被声明为抽象类，防止被实例化。
2、抽象类特点
（1）抽象类不能实例化，即不能对其用new运算符；
（2）类中如果有一个或多个abstract方法，则该类必须声明为abstract；
（3）抽象类中的方法不一定都是abstract方法，它还可以包含一个或者多个具体的方法；
（4）即使一个类中不含抽象方法，它也可以声明为抽象类；
（5）抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用。
（6）如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。
3、什么情况下，使用抽象类
（1）类中包含一个明确声明的抽象方法;
（2）类的任何一个父类包含一个没有实现的抽象方法;
（3）类的直接父接口声明或者继承了一个抽象方法，并且该类没有声明或者实现该抽象方法。
4、代码展示
抽象类不能被实例化，抽象方法必须在子类中被实现。请看下面的代码：
import static java.lang.System.*;
public final class Demo{
    public static void main(String[] args) {
        Teacher t = new Teacher();
        t.setName("小明");
        t.work();

        Driver d = new Driver();
        d.setName("小陈");
        d.work();
    }
}
// 定义一个抽象类
abstract class People{
    private String name;  // 实例变量

    // 共有的 setter 和 getter 方法
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return this.name;
    }

    // 抽象方法
    public abstract void work();
}
class Teacher extends People{
    // 必须实现该方法
    public void work(){
        out.println("我的名字叫" + this.getName() + "，大家好...");
    }
}
class Driver extends People{
    // 必须实现该方法
    public void work(){
        out.println("我的名字叫" + this.getName() + "，大家好...");
    }
}
/*
运行结果：
我的名字叫小明，大家好...
我的名字叫小陈，大家好...
*/
5、关于抽象类的几点说明
（1）抽象类不能直接使用，必须用子类去实现抽象类，然后使用其子类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例，也就是可以使用抽象类来充当形参，实际实现类作为实参，也就是多态的应用。
（2）构造函数和静态函数以及final修饰的函数不能使用abstract修饰符。
（3）如果试图创建一个抽象类的实例就会产生编译错误。
（4）如果一个类是非抽象类却包含一个抽象方法，就会产生编译错误。
（5）抽象类中有构造函数。如果抽象类是父类，需要给子类提供实例的初始化。
6、abstract 关键字和哪些关键字不能共存?
final：被final修饰的类不能有子类。而被abstract修饰的类一定是一个父类。
private: 抽象类中的私有的抽象方法，不被子类所知，就无法被复写。而抽象方法出现的就是需要被复写。
static：如果static可以修饰抽象方法，那么连对象都省了，直接类名调用就可以了。可是抽象方法运行没意义。
```

### abstract可以修饰什么？abstract详解

abstract一般用来修饰类和方法。
1.abstract修饰类
abstract修饰类，会使得类变成抽象类，抽象类不能生成实例，但是可以作为对象变量声明的类型，也就是编译时类型。抽象类相当于类的半成品，需要子类继承并覆盖其中的方法。
注意：

- 抽象类虽然不能实例化，但是有自己的构造方法。
- 抽象类和接口(interface)有很大的不同之处，接口中不能有实例方法去实现业务逻辑，而抽象类可以有实例方法，并实现业务逻辑。
- 抽象类不能被final修饰，因为被final修饰的类无法被继承，而对于抽象类来说就是需要通过继承去实现抽象方法。

2.abstract修饰方法
abstract修饰方法会使得这个方法变成抽象方法，也就是只有声明，而没有实现，需要子类重写。
注意：

- 有抽象方法的类一定是抽象类，但是抽象类不一定有抽象方法。
- 父类是抽象类，其中有抽象方法，那么子类继承父类，并把父类中的所有抽象方法都实现了，子类才有创建对象实例的能力，否则子类也必须是抽象类。抽象类中可以有构造方法，子类在构造子类对象时需要调用父类(抽象类)的构造方法。
- 抽象方法不能用private修饰，因为抽象方法必须被子类重写，而private权限对于子类来说是不能访问的，所以就会产生矛盾。
- 抽象方法也不能用static修饰，如果用static修饰了，那么我们就可以直接通过类名调用了，而抽象方法压根没有主体，没有任何业务逻辑，这样就毫无意义了。

3.抽象类的多态性

```java
abstract class E{
    public abstract void show();// public abstract可以省略
}
```

然后其它类继承它通常为了实现它里面的方法。

```java
class F extends{
    void show(){
            写具体代码}
}
```

最后在主方法里定义一个父类引用指向子类对象，就会发生多态现象，比如

```java
E e = new F();
e.show();    
```

实际上调用了子类里面的new()方法。

4.抽象类的构造方法

```java
public abstract class Car {
	
 Car(){
  System.out.println("抽象方法无参构造函数");
 }
 Car(String a){
  System.out.println("抽象有参构造方法");
 }
 public void mothod1(){
  System.out.println(this.getClass());
  System.out.println("抽象类的实例方法");
 }
 public abstract void mothod2();
 }
/**
 * 自行车
 */
class Bicycle extends Car{
 Bicycle(){
  System.out.println("子类无参构造函数");
 }
 @Override
 public void mothod2() {//需要覆写抽象方法mothod2
 }
}
/**另一个包的测试类**/
public class Test {
 public static void main(String[] args) {
  Bicycle b = new Bicycle();
  b.mothod1();
 }
}
```

输出：

抽象方法无参构造函数
子类无参构造函数
class com.shaolin.service.impl.Bicycle
抽象类的实例方法

从上面的例子中可以看出：

- 抽象类是有构造方法的（当然如果我们不写，编译器会自动默认一个无参构造方法）。而且从结果来看，和普通的继承类一样，在new 一个子类对象时会优先调用父类（这里指的是抽象类Car）的构造器初始化，然后再调用子类的构造器。至此相信大家都会有这样一个疑问，为什么抽象方法不能实例化却有构造器呢？ 对于这个问题网上也中说纷纭，没有确定答案。
  我是这样想的：既然它也属于继承的范畴，那么当子类创建对象时必然要优先初始化父类的属性变量和实例方法，不然子类怎么继承和调用呢？而它本身不能实例化，因为它本身就是不确定的一个对象，如果它能被实例化，那么我们通过它的对象来调用它本身的抽象方法是不是有问题。所以不能实例化有在情理之中。因此大家只要记住这个规定就行。
- 对于抽象类中的非statci(静态)和非abstract(抽象)方法中的this关键字（静态方法中不能有关键字this，因为static方法可以直接由类名调用，this指代对象，没有实例化就没有对象，所以在static方法中不使用this）代表的是它的继承类，而非抽象类本身，这个好理解，因为抽象类本身不能被实例化。如果有多个继承类，谁调用this就代表谁。

抽象类有什么好处呢？

- 由于抽象类不能被实例化，最大的好处就是通过方法的覆盖来实现多态的属性。也就是运行期绑定
- 抽象类将事物的共性的东西提取出来，由子类继承去实现，代码易扩展、易维护。

### abstract和接口的区别

1.抽象类中可以有普通成员变量，接口中没有普通成员变量。
2.抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以是任意的，但是接口中定义的变量只是public static final类型，并且默认为public static final类型。
3.抽象类可以有构造方法，接口中不能有构造方法。
4.抽象类中可以包含静态方法，接口中不能有静态方法。这里注意，静态方法不要去重写，其次这里的静态方法一定要有具体实现，不能是抽象的。Java8中允许接口中包含静态方法了，可以用接口直接调用。
5.抽象类中抽象方法的访问类型可以是public，protected，但是接口中的抽象方法只能是public类型的，并且默认为public abstract类型的。
6.一个类可以实现多个接口，但是只能继承一个抽象类。

### 关于abstract的一些面试题

- 可以用抽象类来实现接口，这个时候就不需要实现接口的所有方法了。

```
1. Java抽象类可以有构造函数吗？
可以有，抽象类可以声明并定义构造函数。因为你不可以创建抽象类的实例，所以构造函数只能通过构造函数链调用（Java中构造函数链指的是从其他构造函数调用一个构造函数），例如，当你创建具体的实现类。现在一些面试官问，如果你不能对抽象类实例化那么构造函数的作用是什么？好吧，它可以用来初始化抽象类内部声明的通用变量，并被各种实现使用。另外，即使你没有提供任何构造函数，编译器将为抽象类添加默认的无参数的构造函数，没有的话你的子类将无法编译，因为在任何构造函数中的第一条语句隐式调用super()，Java中默认超类的构造函数。
2. Java抽象类可以实现接口吗？它们需要实现所有的方法吗？
可以，抽象类可以通过使用关键字implements来实现接口。因为它们是抽象的，所以它们不需要实现所有的方法。好的做法是，提供一个抽象基类以及一个接口来声明类型 。这样的例子是，java.util.List接口和相应的java.util.AbstractList抽象类。因为AbstractList实现了所有的通用方法，具体的实现像LinkedList和ArrayList不受实现所有方法的负担，它们可以直接实现List接口。这对两方面都很好，你可以利用接口声明类型的优点和抽象类的灵活性在一个地方实现共同的行为。Effective Java有个很好的章节，介绍如何使用Java的抽象类和接口，值得阅读。
3. Java抽象类可以是final的吗？
不可以，Java抽象类不能是final的。将它们声明为final的将会阻止它们被继承，而这正是使用抽象类唯一的方法。它们也是彼此相反的，关键字abstract强制继承类，而关键字final阻止类被扩张。在现实世界中，抽象表示不完备性，而final是用来证明完整性。底线是，你不能让你的Java类既abstract又final，同时使用，是一个编译时错误。
4. Java抽象类可以有static方法吗？
可以，丑娘类可以声明并定义static方法，没什么阻止这样做。但是，你必须遵守Java中将方法声明为static的准则，因为在面向对象的设计中是不受欢迎的，因为Java中的static方法是不可以被重载的。在抽象类中看到static方法是罕见的，但正如我所说的，如果你有很好的理由这样做的话，那没有什么可以阻止你。
5. 可以创建抽象类的实例吗？
不可以，你不能创建Java抽象类的实例，它们是不完全的。即使你的抽象类不包含任何抽象方法，你也不能对它实例化。将类声明为abstract的，就等你你告诉编译器，它是不完全的不应该被实例化。当一段代码尝试实例化一个抽象类时Java编译器会抛错误。
6. 抽象类必须有抽象方法吗？
不需要，抽象类有抽象方法不是强制性的。你只需要使用关键字abstract就可以将类声明为抽象类。编译器会强制所有结构的限制来适用于抽象类，例如，现在允许创建一些实例。是否在抽象类中有抽象方法是引起争论的。我的观点是，抽象类应该有抽象方法，因为这是当程序员看到那个类并做假设的第一件事。这也符合最小惊奇原则。
7. Java抽象类和接口有何不同？
很容易回答核心OOPS的概念，如抽象，封装，多态和继承，但是，当涉及到微妙点就是这样，候选人往往失手。
8. 何时选用抽象类而不是接口？
这是对之前抽象类和接口对比问题的后续。如果你知道语法差异，你可以很容易回答这个问题，因为它们可以令你做出抉择。当关心升级时，因为不可能在一个发布的接口中添加一个新方法，用抽象类会更好。类似地，如果你的接口中有很多方法，你对它们的实现感到很头疼，考虑提供一个抽象类作为默认实现。这是Java集合包中的模式，你可以使用提供默认实现List接口的AbstractList。
9. Java中的抽象方法是什么？
抽象方法是一个没有方法体的方法。你仅需要声明一个方法，不需要定义它并使用关键字abstract声明。Java接口中所有方法的声明默认是abstract的。这是抽象方法的例子
public void abstract printVersion();
现在，为了实现这个方法，你需要继承该抽象类并重载这个方法。
10. Java抽象类中可以包含main方法吗？
是的，抽象类可以包含main方法，它只是一个静态方法，你可以使用main方法执行抽象类，但不可以创建任何实例。
```

### 重写object对象的equasl方法时，通常还要重写哪个方法

```
hashcode(),构造方法
```

### 虚拟机栈知识点

```
（1）虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。换句话说，一个 Java线程的运行状态，由一个虚拟机栈来保存，所以虚拟机栈肯定是线程私有的，独有的，随着 线程的创建而创建 
（2）每一个被线程执行的方法，为该栈中的栈帧，即每个方法的执行对应一个栈帧 
（3）调用一个方法，就会向栈中压入一个栈帧；一个方法调用完成，就会把该栈帧从栈中弹出
栈桢
每个栈帧对应一个被调用的方法，可以理解为一个方法的运行空间。 每个栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、动态链接、方法返 回地址(Return Address)和附加信息。
```

### Jvm可达性分析，哪个对象可作为root

```
由GC Root出发，开始寻找，看看某个对象是否可达：类加载器、Thread、本地变量表、static成员、常用引用、本地方法栈中的变量等
```

### 组合索引会出现什么问题

```
组合索引的最左原则
```

### create Table user之后，user表中只有id列，那么可以插入重复id吗？

```
这个问题问的，当然要看有没有设置索引（唯一索引），有没有设置主键
```

###  写一个delete语句，删除表中重复元素

![image-20220218124234858](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220218124234858.png)

### object的方法有哪些

```
clone(),getClass(),registerNatives(),hashCode(),toString(),notify(),notifyAll(),wait(),finalize(),equals()
```

### Spring循环依赖

```
singletonObjects： 一级缓存，存储单例对象，Bean 已经实例化，初始化完成。
earlySingletonObjects： 二级缓存，存储 singletonObject，这个 Bean 实例化了，还没有初始化。
singletonFactories： 三级缓存，存储 singletonFactory。

所有被 Spring 管理的 Bean，最终都会存放在 singletonObjects 中，这里面存放的 Bean 是经历了所有生命周期的（除了销毁的生命周期），完整的，可以给用户使用的。
earlySingletonObjects 存放的是已经被实例化，但是还没有注入属性和执行 init 方法的 Bean。
singletonFactories 存放的是生产 Bean 的工厂。

为什么不能用三级缓存
Bean 都已经实例化了，为什么还需要一个生产 Bean 的工厂呢？这里实际上是跟 AOP 有关，如果项目中不需要为 Bean 进行代理，那么这个 Bean 工厂就会直接返回一开始实例化的对象，如果需要使用 AOP 进行代理，那么这个工厂就会发挥重要的作用了，这也是本文需要重点关注的问题之一。


```

![preview](https://segmentfault.com/img/remote/1460000039091694/view)

### Synchronized加在方法上和加在静态方法上的区别？

```
对于普通同步方法，锁是当前实例对象。
对于静态同步方法，锁是当前类的Class对象。
对于同步方法块，锁是Synchonized括号里配置的对象。
```

![image-20220218131240830](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220218131240830.png)

### ReentrantLock和Synchronized区别

```
一个持有锁的线程，在释放锁之前，如果再次访问加了该同步锁的其他方法， 这个线程不需要再次争抢锁，只需要记录重入次数

使用方式
Synchronized可以修饰实例方法，静态方法，代码块。自动释放锁。
ReentrantLock一般需要try catch finally语句，在try中获取锁，在finally释放锁。需要手动释放锁。
实现方式
Synchronized是重量级锁。重量级锁需要将线程从内核态和用户态来回切换，耗费系统资源。
ReentrantLock是轻量级锁。采用cas+volatile管理线程，不需要线程切换，获取锁线程觉得自己肯定能成功，这是一种乐观的思想（可能失败）。
需要注意的是：这是两种不一样的思维方式，前者是被动阻塞悲观锁，状态是block，后者是主动的阻塞乐观锁，状态是wait。

公平和非公平
Synchronized只有非公平锁。
ReentrantLock提供公平和非公平两种锁，默认是非公平的。公平锁通过构造函数传递true表示。

可重入锁
Synchronized和ReentrantLock都是可重入的，Synchronized是本地方法是C++实现，而ReentrantLock是JUC包用Java实现。
在ReentrantLock中，重入次数用整形state表示。进入1次递增1次，出来1次递减1次。

可中断的
Synchronized是不可中断的。
ReentrantLock提供可中断和不可中断两种方式。其中lockInterruptibly方法表示可中断，lock方法表示不可中断。

条件队列
Synchronized只有一个等待队列。
ReentrantLock中一把锁可以对应多个条件队列。通过newCondition表示。

同步队列：多线程同时竞争一把锁失败被挂起的线程。
条件队列：正在执行的线程调用await/wait，从同步队列加入的线程会进入条件队列。正在执行线程调用signal/signalAll/notify/notifyAll，会将条件队列一个线程或多个线程加入到同步队列。
等待队列：和条件队列一个概念。
```

### 什么是线程同步？

```
线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。
```

### 怎么实现线程同步？

```java
1.同步方法 
即有synchronized关键字修饰的方法。 
由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。
代码如： 
public synchronized void save(){}
注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类 
    
2.同步代码块
即有synchronized关键字修饰的语句块。 
被该关键字修饰的语句块会自动被加上内置锁，从而实现同步
代码如： 
synchronized(object){ }
注：同步是一种高开销的操作，因此应该尽量减少同步的内容。 
通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。 
package com.xhj.thread;
    /**
     * 线程同步的运用
     */
    public class SynchronizedThread {
        class Bank {
            private int account = 100;
            public int getAccount() {
                return account;
            }
            /**
             * 用同步方法实现
             */
            public synchronized void save(int money) {
                account += money;
            }
            /**
             * 用同步代码块实现
             */
            public void save1(int money) {
                synchronized (this) {
                    account += money;
                }
            }
        }
        class NewThread implements Runnable {
            private Bank bank;
            public NewThread(Bank bank) {
                this.bank = bank;
            }
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    // bank.save1(10);
                    bank.save(10);
                    System.out.println(i + "账户余额为：" + bank.getAccount());
                }
            }
        }
        /**
         * 建立线程，调用内部类
         */
        public void useThread() {
            Bank bank = new Bank();
            NewThread new_thread = new NewThread(bank);
            System.out.println("线程1");
            Thread thread1 = new Thread(new_thread);
            thread1.start();
            System.out.println("线程2");
            Thread thread2 = new Thread(new_thread);
            thread2.start();
        }
        public static void main(String[] args) {
            SynchronizedThread st = new SynchronizedThread();
            st.useThread();
        }
    }
3.使用特殊域变量(volatile)实现线程同步
 volatile关键字为域变量的访问提供了一种免锁机制， 
 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， 
 因此每次使用该域就要重新计算，而不是使用寄存器中的值 
 volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 
 例如： 在上面的例子当中，只需在account前面加上volatile修饰，即可实现线程同步。 
代码实例： 
//只给出要修改的代码，其余代码与上同
        class Bank {
            //需要同步的变量加上volatile
            private volatile int account = 100;
            public int getAccount() {
                return account;
            }
            //这里不再需要synchronized
            public void save(int money) {
                account += money;
            }
        ｝
注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 用final域，有锁保护的域和volatile域可以避免非同步的问题。  

4.使用重入锁实现线程同步 
在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。 
ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力
ReenreantLock类的常用方法有：
ReentrantLock() : 创建一个ReentrantLock实例 
lock() : 获得锁 
unlock() : 释放锁    
注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用 
例如： 在上面例子的基础上，改写后的代码为: 代码实例： 
//只给出要修改的代码，其余代码与上同
        class Bank {
            private int account = 100;
            //需要声明这个锁
            private Lock lock = new ReentrantLock();
            public int getAccount() {
                return account;
            }
            //这里不再需要synchronized
            public void save(int money) {
                lock.lock();
                try{
                    account += money;
                }finally{
                    lock.unlock();
                }
            }
        ｝
注：关于Lock对象和synchronized关键字的选择： 
最好两个都不用，使用一种java.util.concurrent包提供的机制, 能够帮助用户处理所有与锁相关的代码。 
如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 
如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁 　　

5.使用局部变量实现线程同步     
如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， 
副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。
ThreadLocal 类的常用方法
ThreadLocal() : 创建一个线程本地变量 
get() : 返回此线程局部变量的当前线程副本中的值 
initialValue() : 返回此线程局部变量的当前线程的"初始值" 
set(T value) : 将此线程局部变量的当前线程副本中的值设置为value
例如： 
在上面例子基础上，修改后的代码为： 
代码实例： 
//只改Bank类，其余代码与上同
        public class Bank{
            //使用ThreadLocal类管理共享变量account
            private static ThreadLocal<Integer> account = new ThreadLocal<Integer>(){
                @Override
                protected Integer initialValue(){
                    return 100;
                }
            };
            public void save(int money){
                account.set(account.get()+money);
            }
            public int getAccount(){
                return account.get();
            }
        }
注：ThreadLocal与同步机制 
 a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。 
 b.前者采用以"空间换时间"的方法，后者采用以"时间换空间"的方式
    
6.使用阻塞队列实现线程同步
前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。 
使用javaSE5.0版本中新增的java.util.concurrent包将有助于简化开发。 
本小节主要是使用LinkedBlockingQueue<E>来实现线程的同步 
LinkedBlockingQueue<E>是一个基于已连接节点的，范围任意的blocking queue。 
LinkedBlockingQueue 类常用方法
LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue 
put(E e) : 在队尾添加一个元素，如果队列满则阻塞 
size() : 返回队列中的元素个数 
take() : 移除并返回队头元素，如果队列空则阻塞 
代码实例：
实现商家生产商品和买卖商品的同步
import java.util.Random;
import java.util.concurrent.LinkedBlockingQueue;
/**
 * 用阻塞队列实现线程同步 LinkedBlockingQueue的使用
 */
public class BlockingSynchronizedThread {
    /**
     * 定义一个阻塞队列用来存储生产出来的商品
     */
    private LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<Integer>();
    /**
     * 定义生产商品个数
     */
    private static final int size = 10;
    /**
     * 定义启动线程的标志，为0时，启动生产商品的线程；为1时，启动消费商品的线程
     */
    private int flag = 0;
 
    private class LinkBlockThread implements Runnable {
        @Override
        public void run() {
            int new_flag = flag++;
            System.out.println("启动线程 " + new_flag);
            if (new_flag == 0) {
                for (int i = 0; i < size; i++) {
                    int b = new Random().nextInt(255);
                    System.out.println("生产商品：" + b + "号");
                    try {
                        queue.put(b);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    System.out.println("仓库中还有商品：" + queue.size() + "个");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            } else {
                for (int i = 0; i < size / 2; i++) {
                    try {
                        int n = queue.take();
                        System.out.println("消费者买去了" + n + "号商品");
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    System.out.println("仓库中还有商品：" + queue.size() + "个");
                    try {
                        Thread.sleep(100);
                    } catch (Exception e) {
                        // TODO: handle exception
                    }
                }
            }
        }
    }
    public static void main(String[] args) {
        BlockingSynchronizedThread bst = new BlockingSynchronizedThread();
        LinkBlockThread lbt = bst.new LinkBlockThread();
        Thread thread1 = new Thread(lbt);
        Thread thread2 = new Thread(lbt);
        thread1.start();
        thread2.start();
    }
}
注：BlockingQueue<E>定义了阻塞队列的常用方法，尤其是三种添加元素的方法，我们要多加注意，当队列满时：
add()方法会抛出异常
offer()方法返回false
put()方法会阻塞
    
7.使用原子变量实现线程同步
需要使用线程同步的根本原因在于对普通变量的操作不是原子的。那么什么是原子操作呢？
原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作
即-这几种行为要么同时完成，要么都不完成。
在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，
使用该类可以简化线程同步。
其中AtomicInteger表可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，
但不能用于替换Integer；可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。
AtomicInteger类常用方法：
AtomicInteger(int initialValue) : 创建具有给定初始值的新的AtomicInteger
addAddGet(int dalta) : 以原子方式将给定值与当前值相加
get() : 获取当前值
代码实例：
只改Bank类，其余代码与上面第一个例子同
class Bank {
        private AtomicInteger account = new AtomicInteger(100);
 
        public AtomicInteger getAccount() {
            return account;
        }
 
        public void save(int money) {
            account.addAndGet(money);
        }
    }
补充--原子操作主要有：
对于引用变量和大多数原始变量(long和double除外)的读写操作；
对于所有使用volatile修饰的变量(包括long和double)的读写操作。
```

### 解释下什么是Join？

```
保证线程执行结果的可见性，本质是wait/notifyall
```

### InputStream和reader区别

```
一个是字节输入流，一个是字符输入流。对于中文如果是字节输入流可能会乱码，使用字符输入流
```

### 讲一下springBoot常用的注解

```
springbootapplication,configuration,enableautoconfiguration,componentscan,autowired,reference,component,repository,service,controller,resucontroller,requestmapping,scope,pathvaricable,requestparam,requestbody,value,configurationproperties,propertysource,参数校验的notempty,notblank,notnull,size....
```

### int范围，怎么计算的

```
-2的31方-2的31方-1   4字节，31位，一位符号位
```

### 常用的集合有哪些？简单说下

```
看之前课程的课件
```

### 合并两个链表，将两个链表合并成一个有序链表

```
修改指针即可
```

### 查出表中语文成绩第二的人.(语言描述)

![image-20220218213528246](C:\Users\WFQ\AppData\Roaming\Typora\typora-user-images\image-20220218213528246.png)

### 查出表中语文成绩并列前三的人.(语言描述)

```
先子查询去重成绩查出第三的成绩，然后在查出成绩比第三成绩大的数据
```

### 线程池如果没有使用，核心线程是否会消失

```
不会
1.线程池是怎么保证他的核心线程不释放 而一直等待任务的执行的呢？
2.我们一直理解的线程run方法执行完毕线程就销毁是不正确的？
3.还有我们为何通过设置allowCoreThreadTimeOut(true) 就能使核心线程销毁的呢？
答案：
1.线程阻塞
2.和那个关系不大
3.可以的
```

可以看看下面的源码分析：

从 exexute 方法开始：

```java
public void execute(Runnable command) {

        //如果提交的任务为null  抛出异常
        if (command == null)
            throw new NullPointerException();
        // 线程池是通过Integer类型的 高3位 表述当前线程池的状态RUNNING，SHUTDOWN，STOP，TIDYING，TERMINATED 。
        // 低29位表示当前线程的运行任务数量。然后通过位运算来计算运行状态和任务的数量。
        int c = ctl.get();
        //1.如果当前的任务数小于等于设置的核心线程大小，那么调用addWorker直接执行该任务
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        //2.如果当前的任务数大于设置的核心线程大小，而且当前的线程池状态时运行状态，那么向阻塞队列中添加任务
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        //3.如果向队列中添加失败，那么就新开启一个线程来执行该任务
        else if (!addWorker(command, false))
            reject(command);
    }
```

下面看看 addWorker 方法：

```java
private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        //一直尝试，
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);
            // Check if queue empty only if necessary.
            // 如果当前线程池的状态时SHUTDOWN，STOP，TIDYING，TERMINATED
            // 并且为SHUTDOWN状态时任务队列为空，那么就返回false
            // 原因：如果调用了shutdown方法，此时的线程池还会继续工作并且会在任务队列中的所有任务执行完成后才会结束线程池。
            if (rs >= SHUTDOWN &&
                    ! (rs == SHUTDOWN &&
                            firstTask == null &&
                            ! workQueue.isEmpty()))
                return false;
            for (;;) {
                //
                int wc = workerCountOf(c);
                //core是在execute方法中传的参数:true表示 核心线程，false表示最大线程
                //CAPACITY  可以理解为Integer的最大值  1左移29位再-1
                if (wc >= CAPACITY ||
                        wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;

                //如果增加任务数量成功那么退出这个循环执行下面的代码，否则继续
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            //
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    //再判断一次当前线程池的状态  避免在执行过程中线程时被使用者关闭
                    int rs = runStateOf(ctl.get());
                    if (rs < SHUTDOWN ||
                            (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        //向正在执行的任务队列(workers)中添加work
                        // 区别一下：workqueue 是等待执行的阻塞队列
                        workers.add(w);
                        int s = workers.size();

                        //记录曾经并发执行的最大任务个数
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        //添加任务成功
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    //如果任务添加成功那么开始执行任务
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```

下面看看 Worker 类的run 方法，实际是调用的ThreadPoolExecutor#runWorker方法：

```java
final void runWorker(ThreadPoolExecutor.Worker w) {
        Thread wt = Thread.currentThread();
        //得到worker对象中我们提交的任务
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            //如果当前任务为空  那么就从getTask中获得任务
            while (task != null || (task = getTask()) != null) {
                w.lock();
                if ((runStateAtLeast(ctl.get(), STOP) ||
                        (Thread.interrupted() &&
                                runStateAtLeast(ctl.get(), STOP))) &&
                        !wt.isInterrupted())
                    wt.interrupt();
                try {
                    //任务执行前调用的方法
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        //任务结束后调用的方法
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
```

下面看看 getTask 方法：

```java
private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);
            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }
            int wc = workerCountOf(c);
            // Are workers subject to culling?
            //从阻塞任务队列中取任务，如果设置了allowCoreThreadTimeOut(true)
            // 或者
            // 当前运行的任务数大于设置的核心线程数，那么timed =true
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

            if ((wc > maximumPoolSize || (timed && timedOut))
                    && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }
            try {
                //根据 timed true 或 false 来判断从哪里取任务，是否超时取任务
                Runnable r = timed ?
                        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                        // take()会一直阻塞，等待任务的添加。
                        workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```

到这里，所有的谜团都解开了。

### ArrayList和LinkedList区别（底层实现区别）

```
ArrayList 与 LinkedList 都是 List 接口的实现类，因此都实现了 List 的所有未实现的方法，只是实现的方式有所不同。

ArrayList 是基于动态数组数据结构的实现，访问元素速度优于 LinkedList。LinkedList 是基于链表数据结构的实现，占用的内存空间比较大，但在批量插入或删除数据时优于 ArrayList。

对于快速访问对象的需求，使用 ArrayList 实现执行效率上会比较好。需要频繁向集合中插入和删除元素时，使用 LinkedList 类比 ArrayList 类效果高。

不同的结构对应于不同的算法，有的考虑节省占用空间，有的考虑提高运行效率，对于程序员而言，它们就像是“熊掌”和“鱼肉”，不可兼得。高运行速度往往是以牺牲空间为代价的，而节省占用空间往往是以牺牲运行速度为代价的。
```

### ArrayList怎么删除元素？

```java
# remove方法：移除指定的元素
public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);
    // 记录要移动的元素的个数
    int numMoved = size - index - 1;
    if (numMoved > 0)
// 源数组 开始下标  目标数组 开始下标  长度
        System.arraycopy(elementData, index+1, elementData, index,numMoved);
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
```

### HashMap底层实现

![image-20220219132512798](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220219132512798.png)

```
Jdk1.7及以前是采用数组+链表
Jdk1.8之后
采用数组+链表  或者  数组+红黑树方式进行元素的存储
存储在hashMap集合中的元素都将是一个Map.Entry的内部接口的实现

当数组的下标位是链表时,此时存储在该下标位置的内容将是Map.Entry的一个实现Node内部类对象
当数组的下标位是红黑树时,此时存储在该下标位置的内容将是Map.Entry的一个实现TreeNode内部类对象
链表长度>8转红黑树  默认初始长度16 负载因子0.75
```

### new HashTable()的创建过程



Java反射相关知识

jdk反射机制

redis的雪崩是什么，如何处理

sql的优化

线程私有区

怎么处理数据库中查回的10000条数据？

幂等性问题

线程池参数怎么设置

JMM相关知识

Explain查看sql执行计划

```

```

多线程如何优化.

什么是函数方法？

什么是函数式接口

什么是泛型，谈谈你对泛型的理解

数据库并发怎么控制？

什么是开闭原则？
什么是开，什么是闭？

```
对扩展开放，对修改关闭
```

什么是包装模式？

平时接触过哪些设计模式？

后台server怎么推送消息给H5页面

Eurrake保证了cap中的哪些特性

Spring el表达式

分布式框架有哪些

Quartz定时器怎么实现

Mybaits和数据库连接池相关知识

单体应用和微服务的区别

Timer有哪些重要的API以及这些API是怎么实现的

Netty相关知识

RabbitMQ相关知识

nacos zookeeper dubbo 多线程

```
项目中有哪些难点以及怎么遇到的问题
在项目中你遇到过什么问题.
在项目中你如何与别人沟通.
登陆问的多
```

### 排序算法有几种复杂度怎么样

![image-20220219124457589](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220219124457589.png)

### 谈谈你对算法的认识

```
解决某个问题的方法、步骤
有限性（Finiteness）：一个算法必须保证执行有限步之后结束。
确切性（Definiteness）： 一个算法的每一步骤必须有确切的定义。
输入（Input）：一个算法有零个或多个输入，以刻画运算对象的初始情况，所谓零个输入是指算法本身给定了初始条件。
输出（Output）：一个算法有一个或多个输出。没有输出的算法毫无意义。
可行性（Effectiveness）： 一个算法的任何计算步骤都是可以被分解为基本可执行的操作，每个操作都能够在有限时间内完成。
```

### 什么是最优二叉树？

```
给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
```

![img](https://img-blog.csdnimg.cn/img_convert/5f9c080f35fce34fcdd206a170e95e3a.png)

### 怎么实现最优二叉树？

```
第一次取所有节点中权值最小的节点，他们两个作为子节点，计算父节点的权值（他们两个子节点权值和），然后将父节点这个二叉树放入节点中，在从中选出权值最小的两个进行计算父节点权值放入其中
```

