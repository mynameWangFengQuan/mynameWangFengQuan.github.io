### 面试准备

### 一、英文自我介绍准备

1.自我介绍范文（仅供参考）
Good morning/afternoon/evening, my name is XXX. I’m 24 years old. I came from XXX city of XXX province.
I graduated from shandong University of XXX University in 2020. My major is computer science and technology. I have large enthusiasm in programming. I learned very hard and learned Java by myself during the college.
After graduate, I found a job in a  XXX IT company. I have worked in this company for one years. I can mastered the mainstream developing technology such as Spring, SpringBoot,SpringClould, Spring MVC, Mybatis, I also can use the database like MYSQL; For the front end, jQuery framework such as Easy UI and Bootstrap was also involved in my work.
Now I’d like to find a job in ShangHai,which one I want to improve my English and technique. I’m very interested in HSBC’s opportunity and hope to join your team if possible. Thanks for your listening.

### Java基本数据类型   

```
byte,short,int,long,float,double,char,boolean
```

### equals与hashcode ==和equals的区别

```
1.equals与hashcode
①第一种 不会创建“类对应的散列表”
	这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。
	在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！
    这种情况下，equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。
②第二种 会创建“类对应的散列表”
	 1)、如果两个对象相等，那么它们的hashCode()值一定相同。这里的相等是指，通过equals()比较两个对象时返回true。
     2)、如果两个对象hashCode()相等，它们并不一定相等。
     因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。
     此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。
2.==和equals的区别
	== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不试同一个对象。
    equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
    情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。
    情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)
```

### int有几个字节？

```
4字节
```

### 一个字节占几位？

```
8位(b)
```

### java多线程有几种创建方式，线程状态有哪些 

```
1.继承Thread类，重写run()方法
2.实现Runnable接口，重写run()方法
3.匿名内部类的形式（本质也是Thread和Runnable的形式）
4.带返回值的线程(实现implements Callable<返回值类型>)
5.Executor，ThreadPoolExecutor

New：新创建的线程，尚未执行；
Runnable：运行中的线程，正在执行run()方法的Java代码；
Blocked：运行中的线程，因为某些操作被阻塞而挂起；
Waiting：运行中的线程，因为某些操作在等待中；
Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；
Terminated：线程已终止，因为run()方法执行完毕。
用一个状态转移图表示如下：

         ┌─────────────┐
         │     New     │
         └─────────────┘
                │
                ▼
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
 ┌─────────────┐ ┌─────────────┐
││  Runnable   │ │   Blocked   ││
 └─────────────┘ └─────────────┘
│┌─────────────┐ ┌─────────────┐│
 │   Waiting   │ │Timed Waiting│
│└─────────────┘ └─────────────┘│
 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
                │
                ▼
         ┌─────────────┐
         │ Terminated  │
         └─────────────┘
当线程启动后，它可以在Runnable、Blocked、Waiting和Timed Waiting这几个状态之间切换，直到最后变成Terminated状态，线程终止。
线程终止的原因有：
线程正常终止：run()方法执行到return语句返回；
线程意外终止：run()方法因为未捕获的异常导致线程终止；
对某个线程的Thread实例调用stop()方法强制终止（强烈不推荐使用）。
一个线程还可以等待另一个线程直到其运行结束。例如，main线程在启动t线程后，可以通过t.join()等待t线程结束后再继续运行：
```

![匿名内部类](https://user-images.githubusercontent.com/43489916/154788051-f1c06019-aab5-4b26-8fab-d6e08af04770.png)

### 设计模式的六大设计原则 

#### 单一职责原则的定义（类、方法、接口）

单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。

该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：

1. 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
2. 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。

##### 单一职责原则的优点

单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。

- 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
- 提高类的可读性。复杂性降低，自然其可读性会提高。
- 提高系统的可维护性。可读性提高，那自然更容易维护了。
- 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。

##### 单一职责原则的实现方法

单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。

##### 示例

```java
public interface UserService {
    
    public void login(String username, String password);
    public void register(String email, String username, String password);
    public void logError(String msg);
    public void sendEmail(String email);
    
}
```

```
这段代码很显然存在很大的问题，UserService 既要负责用户的注册和登录，还要负责日志的记录和邮件的发送，并且后者的行为明显区别于前者。
假设我要修改发送邮件的逻辑就得修改这个类，这时候 qa 还得回归登录注册逻辑，这样明显不合理。
```

因此我们需要进行拆分，根据具体的职能可将其具体拆分如下：

**UserService**：只负责登录注册

```java
public interface UserService {

    public void login(String username, String password);
    public void register(String email, String username, String password);

}
```

**LogService ：**`只负责日志`

```java
public interface LogService {

    public void logError(String msg);

}
```

**EmailService**： 只负责发送邮件

```java
public interface EmailService {

    public void sendEmail(String email);

}
这时候，咱们再去回顾前面提到的优点，就能深深体会了。
```

这里只是讲了接口，其实对类也一样，甚至方法也是一样的。

对于类来说，根据类名，确保里面提供的方法都是属于这个类的。

对于方法，不要把不相关的对象实例作为参数传进来。如果你发现某个方法依赖某个不相关的对象，那么这个方法的实现可能就存在问题。

比如 android 中图片下载后显示到 imageView 中，我提供如下的方法：

```
loadImage(String url, ImageView view) {

// 下载图片，展示图片

}
```

对于 loadImage 这个方法，参数 url 是ok 的，但是参数 ImageView 却是不合理的。因为这里做了两个操作，下载图片，展示图片。应该将这个方法在进行拆分：

```java
// 下载图片 
loadImage(String url) {

}
// 显示图片
displayImage(String url, ImageView view) {

// 调用 getBitmap (url)  获取图片
// 获取图片后将其设置到 view 中。

}

// 根据 url 获取图片， 
getBitmap(String url) {

}
```

这样整个逻辑就很清晰。后续需要修改下载逻辑，也不会影响到展示逻辑。当然其实还有个问题是，这两个方法要不要放在一个类里面？

#### 开闭原则

开闭原则的实现方法：可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

##### 示例

```java
// 矩形
public class Rectangle {

    public double getWidth() {
        return width;
    }
    
    public double getHeight() {
        return height;
    }

} 
```

需要计算矩形的面积

```java
// 面积计算器
public class AreaCalculator {

    public double area(Rectangle shape){
        return shape.getWidth() * shape.getHeight();
    }
}
```

假设这时候，又多了一个圆形类

```java
// 圆形
public class Circular {

    public double getRadius(){
        return radius;
    }
}
```

同样也需要计算他的面积，这时候就会变成下面这样子：

```java
public class AreaCalculator {

    public double area(Object shape){
        if(shape instanceof Rectangle) {
            Rectangle rectangle = (Rectangle) shape;
            return rectangle.getWidth() * rectangle.getHeight();
        } else if (shape instanceof Circular) {
            Circular circular = (Circular) shape;
            return circular.getRadius() * circular.getRadius() * Math.PI;
        } else {
            throw new RuntimeException("There is no such type.");
        }
    }
}
```

这么更改完成，完全没有问题。但是在真实的生产环境中，情况更为复杂，更改涉及的部分较多，那样就可能导致牵一发动全身。并且，以前编写的经过测试的一些功能需要重新测试，甚至导致某些功能不可用。

改进版，把计算面积这个公有逻辑变成一个接口：

```java
public interface Shape {

    public double getArea();

}
 
public class Rectangle implements Shape{

    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    public double getArea() {
        return getWidth() * getHeight();
    }
    
}
```

这样，当需求变更，需要计算圆形面积的时候，我们只需创建一个圆形的类，并实现 Shape 接口即可:

```java
public class Circular implements Shape {

    public double getRadius(){
        return radius;
    }

    public double getArea() {
        return getRadius() * getRadius() * Math.PI;
    }
}
```

计算三角形面积、四边形面积... 的时候，我们只需让它们去实现 Shape 接口即可，无需修改源代码。

#### 里氏替换原则

里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。

##### 里氏替换原则的作用

里氏替换原则的主要作用如下。

1. 里氏替换原则是实现开闭原则的重要方式之一。
2. 它克服了继承中重写父类造成的可复用性变差的缺点。
3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
4. 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。

##### 里氏替换原则的实现方法（继承）

里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

根据上述理解，对里氏替换原则的定义可以总结如下：

- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
- 子类中可以增加自己特有的方法
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
- 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等

通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。

如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。

这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。

关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。

对于正方形和长方形最好的做法是再添加一个父类，他们同时继承自这个父类。

#### 依赖倒置（抽线细节）

依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。

由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。

使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。

##### 依赖、倒置原则的作用

依赖倒置原则的主要作用如下。

- 依赖倒置原则可以降低类间的耦合性。
- 依赖倒置原则可以提高系统的稳定性。
- 依赖倒置原则可以减少并行开发引起的风险。
- 依赖倒置原则可以提高代码的可读性和可维护性。

##### 依赖倒置原则的实现方法

依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。

1. 每个类尽量提供接口或抽象类，或者两者都具备。
2. 变量的声明类型尽量是接口或者是抽象类。
3. 任何类都不应该从具体类派生。
4. 使用继承时尽量遵循里氏替换原则。

依赖倒置原则在“顾客购物程序”中的应用。

分析：本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物

```
 class Customer {
    public void shopping(ShaoguanShop shop) {
        //购物
        System.out.println（shop.sell());
    }
}
```

但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下：

```
class Customer {
    public void shopping(WuyuanShop shop) {
        //购物
        System.out.println(shop.sell());
    }
}
```

顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。

存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。

解决方法是：定义“婺源网店”和“韶关网店”的共同接口 Shop，顾客类面向该接口编程，其代码修改如下：

```
class Customer {
    public void shopping(Shop shop) {
        //购物
        System.out.println(shop.sell());
    }
}

class Customer {
    public void shopping(Shop shop) {
        //购物
        System.out.println(shop.sell());
    }
}
```

这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类如下图所示：


![顾客购物程序的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113131610L7.gif)
程序代码如下：

```
package principle;
public class DIPtest
{
    public static void main(String[] args)
    {
        Customer wang=new Customer();
        System.out.println("顾客购买以下商品："); 
        wang.shopping(new ShaoguanShop()); 
        wang.shopping(new WuyuanShop());
    }
}
//商店
interface Shop
{
    public String sell(); //卖
}
//韶关网店
class ShaoguanShop implements Shop
{
    public String sell()
    {
        return "韶关土特产：香菇、木耳……"; 
    } 
}
//婺源网店
class WuyuanShop implements Shop
{
    public String sell()
    {
        return "婺源土特产：绿茶、酒糟鱼……"; 
    }
} 
//顾客
class Customer
{
    public void shopping(Shop shop)
    {
        //购物
        System.out.println(shop.sell()); 
    }
} 
```

程序的运行结果如下：

```
顾客购买以下商品：
韶关土特产：香菇、木耳……
婺源土特产：绿茶、酒糟鱼……
```

#### 接口隔离原则（接口）

接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。

2002 年罗伯特·C.马丁给“接口隔离原则”的定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。

以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：

- 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
- 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

##### 接口隔离原则的优点

接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。

1. 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
2. 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
3. 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
4. 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
5. 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

##### 接口隔离原则的实现方法

在具体应用接口隔离原则时，应该根据以下几个规则来衡量。

- 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
- 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
- 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
- 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

对于接口隔离，大家还是可以参考单一职责提到的示例：

```
public interface UserService {
    
    public void login(String username, String password);
    public void register(String email, String username, String password);
    public void logError(String msg);
    public void sendEmail(String email);
    
} 
```

这时候，应该就能理解拆分的好处了。

#### 迪米特法则 (类与类之间的关系)

迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知。

迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。

##### 迪米特法则的优点

迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。

1. 降低了类之间的耦合度，提高了模块的相对独立性。
2. 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。

但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。

##### 迪米特法则的实现方法

从迪米特法则的定义和特点可知，它强调以下两点：

1. 从依赖者的角度来说，只依赖应该依赖的对象。
2. 从被依赖者的角度说，只暴露应该暴露的方法。

所以，在运用迪米特法则时要注意以下 6 点。

1. 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
2. 在类的结构设计上，尽量降低类成员的访问权限。
3. 在类的设计上，优先考虑将一个类设置成不变类。
4. 在对其他类的引用上，将引用其他对象的次数降到最低。
5. 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
6. 谨慎使用序列化（Serializable）功能

明星与经纪人的关系实例。

分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则，其类图如下图所示。


![明星与经纪人的关系图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113152Q5W1.gif)
代码如下： 

```java
package principle;
public class LoDtest
{
    public static void main(String[] args)
    {
        Agent agent=new Agent();
        agent.setStar(new Star("林心如"));
        agent.setFans(new Fans("粉丝韩丞"));
        agent.setCompany(new Company("中国传媒有限公司"));
        agent.meeting();
        agent.business();
    }
}
//经纪人
class Agent
{
    private Star myStar;
    private Fans myFans;
    private Company myCompany;
    public void setStar(Star myStar)
    {
        this.myStar=myStar;
    }
    public void setFans(Fans myFans)
    {
        this.myFans=myFans;
    }
    public void setCompany(Company myCompany)
    {
        this.myCompany=myCompany;
    }
    public void meeting()
    {
        System.out.println(myFans.getName()+"与明星"+myStar.getName()+"见面了。");
    }
    public void business()
    {
        System.out.println(myCompany.getName()+"与明星"+myStar.getName()+"洽淡业务。");
    }
}
//明星
class Star
{
    private String name;
    Star(String name)
    {
        this.name=name;
    }
    public String getName()
    {
        return name;
    }
}
//粉丝
class Fans
{
    private String name;
    Fans(String name)
    {
        this.name=name;
    }
    public String getName()
    {
        return name;
    }
}
//媒体公司
class Company
{
    private String name;
    Company(String name)
    {
        this.name=name;
    }
    public String getName()
    {
        return name;
    }
}
```

程序的运行结果如下：

粉丝韩丞与明星林心如见面了。
中国传媒有限公司与明星林心如洽淡业务。

### 什么是数据库连接池？

```
官方：数据库连接池（Connection pooling）是程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由程序动态地对池中的连接进行申请，使用，释放。
个人理解：创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。所以，在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，还更加安全可靠
```

### 当数据库重启之后，数据库连接池里的连接对象还可以使用吗？

```
不可用，他会进行重连操作
　传统统链接:一般来说，Java应用程序访问数据库的过程是：
　　①装载数据库驱动程序；
　　②通过JDBC建立数据库连接；
　　③访问数据库，执行SQL语句；
　　④断开数据库连接。
使用了数据库连接池的机制：
（1） 程序初始化时创建连接池
（2） 使用时向连接池申请可用连接
（3） 使用完毕，将连接返还给连接池
（4） 程序退出时，断开所有连接，并释放资源
```

### 异常：

> https://www.cnblogs.com/cxuanBlog/p/12659578.html

### 异常的继承结构是什么样？Exception的父类是什么？

![image](https://user-images.githubusercontent.com/43489916/154788083-9480b7e5-d899-4386-99ad-97a66391ed6e.png)

### Exception和error的区别是什么？

```
Error 是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。这些错误是不可检查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况，比如 OutOfMemoryError 和 StackOverflowError
Exception 的父类是 Throwable，并且 Exception 有两种异常，一种是 RuntimeException ；一种是 CheckedException，这两种异常都应该去捕获。
```

### 程序没有catch住的异常会被谁catch住？

```
当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try ... catch被捕获为止
```

### 程序没有catch住的异常，怎么处理，handle怎么实现？

#### UncaughtExceptionHandler 是什么

- 它是线程遇到未捕获异常的一个处理者接口
- 它包含一个方法`void uncaughtException(Thread t, Throwable e);` 用来处理接收处理异常发生后的操作，比如收集崩溃信息并上报等
- 可以通过 实例方法 `Thread.setUncaughtExceptionHandler` 为某一个Thread实例设置未捕获异常处理者
- 也可以通过 静态方法 `Thread.setDefaultUncaughtExceptionHandler` 设置所有Thread实例的未捕获异常处理者

#### ThreadGroup 是什么

- ThreadGroup 是线程的集合
- ThreadGroup 也可以包含子ThreadGroup
- 除了初始的ThreadGroup 之外，每个ThreadGroup都有一个父 ThreadGroup
- ThreadGroup 自身实现了Thread.UncaughtExceptionHandler，用来相应处理其内部的线程和ThreadGroup发生未捕获异常。

#### 未捕获异常处理者 设置指南

![how to set uncaught exception handler](https://asset.droidyue.com/image/2019_first_half/how_to_set_uncaught_exceptions.png)

#### 线程发生了未捕获异常，JVM怎么处理

##### 分发Throwable实例

当线程A中出现了未捕获异常时，JVM会调用线程A的`dispatchUncaughtException(Throwable)`方法

```java
private void dispatchUncaughtException(Throwable e) {   							getUncaughtExceptionHandler().uncaughtException(this, e); 
} 
```

##### 获取未捕获异常处理者

- 每个线程会有一个变量(uncaughtExceptionHandler)来保存未捕获异常的处理者
- 在线程需要确定Throwable分发目标的处理者时，优先获取当前线程中uncaughtExceptionHandler变量
- 如果出问题线程的uncaughtExceptionHandler为null（即没有显式设置异常处理者），则使用自己所在的ThreadGroup来作为未捕获异常处理者。

```java
public UncaughtExceptionHandler getUncaughtExceptionHandler() {    
    return uncaughtExceptionHandler != null ? uncaughtExceptionHandler : group; 
} 
```

##### 如果Throwable分发给ThreadGroup

- ThreadGroup会尝试转给它的父ThreadGroup（如果存在的话）
- 如果上面没有找到对应的ThreadGroup，则尝试获取`Thread.getDefaultUncaughtExceptionHandler()`并分发

```java
 public void uncaughtException(Thread t, Throwable e) {        
    if (parent != null) {            
        parent.uncaughtException(t, e);        
    } else {            
        Thread.UncaughtExceptionHandler ueh = Thread.getDefaultUncaughtExceptionHandler();            
        if (ueh != null) {                
            ueh.uncaughtException(t, e);            
        } else if (!(e instanceof ThreadDeath)) {         									 System.err.print("Exception in thread \"" + t.getName() + "\" ");                	  e.printStackTrace(System.err);            
        }        
    }    
 } 
```

##### 初始的ThreadGroup是什么

上面提到了初始的ThreadGroup没有父ThreadGroup，是主线程所在的ThreadGroup么？

初始的ThreadGroup是一个叫做system的ThreadGroup，而不是main ThreadGroup

##### setDefaultUncaughtExceptionHandler 设置的一定会被调用到么

这其实是一个很好的问题，答案是不一定会被调用，因为可能存在以下的情况

- 出问题的线程设置了对应的UncaughtExcpetionHandler，优先响应分发到这个Handler
- 出问题的线程所在的ThreadGroup包括其祖先ThreadGroup 重写了uncaughtException 也可能造成线程默认的Handler无法被调用
- 出问题的线程重写了dispatchUncaughtException 可能性较小
- 出问题的线程重写了getUncaughtExceptionHandler 可能性较小

### 7、运行时异常和非运行时异常的区别？

```markdown
(1)运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。
当出现RuntimeException的时候，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。比如：我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。 
出现运行时异常后，如果没有捕获处理这个异常（即没有catch），系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了。运行时异常是Exception的子类，也有一般异常的特点，是可以被catch块处理的。只不过往往我们不对他处理罢了。也就是说，你如果不对运行时异常进行处理，那么出现运行时异常之后，`要么是线程中止，要么是主程序终止`。 
如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。
(2)非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。
```

### 类加载的机制？

```
1.装载 -- 双亲委派机制（Bootstrap,Extension,app,用户自定义）
(1)通过一个类的全限定名获取定义此类的二进制字节流 
(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 
(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口
2.链接（验证，准备，解析）
(1)验证：保证被加载类的正确性 文件格式验证/元数据验证/字节码验证/符号引用验证 
(2)准备：为类的静态变量分配内存，并将其初始化为默认值 
(3)解析：把类中的符号引用转换为直接引用
3.初始化
对类的静态变量，静态代码块执行初始化操作
```

### 类的生命周期？

```
一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备、解析统称为连接。
四、使用
对象的创建：
对象创建的并发问题：
虚拟机是否使用 TLAB，可以通过 -XX:+/-UseTLAB 参数来设定；
五、卸载
由java虚拟机自带的加载器加载的类，在虚拟机的生命周期中，始终不会被卸载 ，因为java虚拟机本身会一直使用用这些类加载器，而这些类加载器会一直引用它们加载的类的Class对象，因此这些类不会被卸载。
由用户自定义的类加载器加载的类是可以被卸载的。一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。
```

### 什么是final？什么是final类？

```
Java中，final关键字可以用来修饰类（不可被继承）、方法（不能再子类中覆盖重写）和变量（不能修改）（包括成员变量和局部变量）重载是多个同名方法（参数类型，个数，顺序），重写是子类重写父类同名方法
1.修饰类
　　当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。
　　在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。
　　2.修饰方法
　　因此，如果只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。
　　注：类的private方法会隐式地被指定为final方法。
　　3.修饰变量
　　修饰变量是final用得最多的地方，对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
final修饰的变量，无论是类属性、对象属性、形参还是局部变量，都需要进行初始化操作。
```

### 有没有final构造方法？

```
final不能修饰构造方法
构造方法不会被子类继承，final修饰方法就是为了不被重写，所以构造方法没必要加上final修饰
```

##### 被final修饰的变量：三种赋值方式

1. 在定义时直接赋值。
2. 声明时不赋值，在constructor中赋值（最常用的方式）
3. 声明时不赋值，在构造代码块中赋值

>  如果一个非final成员变量在定义的时候没有赋值，那么它只可能在构造函数里被赋值了（不考虑构造代码块的情况）    这个`特性`在JDK以及Spring中都有大量的应用 

```javascript
private final int finalVal = 10;
 private final int finalVal;
    Demo (int val){
        this.finalVal = val;
    }
 private final int finalVal;
    {
        this.finalVal = 10;
    }
```

备注：在看Spring源码的时候，我们会经常看到它定义的final变量，然后对外提供构造函数给与赋值的设计模式。

>  我们得出结论：当你发现一个类的变量被final修饰但没被赋值，那么可以判断出它肯定会在构造函数里被赋值。（因为倘若是set方法赋值，现在是不安全的，因为set方法可以被调用多次，而final变量只能被赋值一次） 

##### 被final static修饰的变量：两种赋值方式

1. 在定义时直接赋值.
2. 在静态代码块里赋值

##### 最后

final变量会经过JVM进行优化处理，所以平时使用过程中建议使用final变量。但更建议读者先重点了解下final变量在JVM中的内存结构后，再频繁使用为佳

### 讲一下String，string为什么设计为final类

**1.为了实现字符串池**

**2.为了线程安全**

**3.为了实现String可以创建HashCode不可变性**

在了解final的用途后，在看String为什么要被final修饰：主要是为了”安全性“和”效率“的缘故。

查看JDK String的源码

![image](https://user-images.githubusercontent.com/43489916/154788108-0241d714-d1d0-4182-966c-0e3fe87198b6.png)

final修饰的String，代表了String的不可继承性，final修饰的char[]代表了被存储的数据不可更改性。但是：虽然final代表了不可变，但仅仅是引用地址不可变，并不代表了数组本身不会变,请看下面图片。

![image](https:////upload-images.jianshu.io/upload_images/11805791-9c6c533a20d89665.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)

 final也可以将数组本身改变的，这个时候，起作用的还有**private**，正是因为两者保证了String的不可变性。

 那么为什么保证String不可变呢,因为**只有当字符串是不可变的，字符串池才有可能实现**。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。

------

如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。

------

 因为字符串是不可变的，所以**是多线程安全的**，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。

-----

因为字符串是不可变的，所以在它创建的时候**HashCode**就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。

### 什么是abstract？

- 1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。

- 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

- 3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。

- 4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。

- 5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

```java
1、概述
（1）只给出方法定义而不具体实现的方法被称为抽象方法，抽象方法是没有方法体的，在代码的表达上就是没有“{}”。使用 abstract 修饰符来表示抽象方法和抽象类。
（2）abstract修饰符表示所修饰的类没有完全实现，还不能实例化。如果在类的方法声明中使用abstract修饰符，表明该方法是一个抽象方法，它需要在子类实现。如果一个类包含抽象方法，则这个类也是抽象类，必须使用abstract修饰符，并且不能实例化。
（3）注意，抽象类除了包含抽象方法外，还可以包含具体的变量和具体的方法。类即使不包含抽象方法，也可以被声明为抽象类，防止被实例化。
2、抽象类特点
（1）抽象类不能实例化，即不能对其用new运算符；
（2）类中如果有一个或多个abstract方法，则该类必须声明为abstract；
（3）抽象类中的方法不一定都是abstract方法，它还可以包含一个或者多个具体的方法；
（4）即使一个类中不含抽象方法，它也可以声明为抽象类；
（5）抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用。
（6）如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。
3、什么情况下，使用抽象类
（1）类中包含一个明确声明的抽象方法;
（2）类的任何一个父类包含一个没有实现的抽象方法;
（3）类的直接父接口声明或者继承了一个抽象方法，并且该类没有声明或者实现该抽象方法。
4、代码展示
抽象类不能被实例化，抽象方法必须在子类中被实现。请看下面的代码：
import static java.lang.System.*;
public final class Demo{
    public static void main(String[] args) {
        Teacher t = new Teacher();
        t.setName("小明");
        t.work();

        Driver d = new Driver();
        d.setName("小陈");
        d.work();
    }
}
// 定义一个抽象类
abstract class People{
    private String name;  // 实例变量

    // 共有的 setter 和 getter 方法
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return this.name;
    }

    // 抽象方法
    public abstract void work();
}
class Teacher extends People{
    // 必须实现该方法
    public void work(){
        out.println("我的名字叫" + this.getName() + "，大家好...");
    }
}
class Driver extends People{
    // 必须实现该方法
    public void work(){
        out.println("我的名字叫" + this.getName() + "，大家好...");
    }
}
/*
运行结果：
我的名字叫小明，大家好...
我的名字叫小陈，大家好...
*/
5、关于抽象类的几点说明
（1）抽象类不能直接使用，必须用子类去实现抽象类，然后使用其子类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例，也就是可以使用抽象类来充当形参，实际实现类作为实参，也就是多态的应用。
（2）构造函数和静态函数以及final修饰的函数不能使用abstract修饰符。
（3）如果试图创建一个抽象类的实例就会产生编译错误。
（4）如果一个类是非抽象类却包含一个抽象方法，就会产生编译错误。
（5）抽象类中有构造函数。如果抽象类是父类，需要给子类提供实例的初始化。
6、abstract 关键字和哪些关键字不能共存?
final：被final修饰的类不能有子类。而被abstract修饰的类一定是一个父类。
private: 抽象类中的私有的抽象方法，不被子类所知，就无法被复写。而抽象方法出现的就是需要被复写。
static：如果static可以修饰抽象方法，那么连对象都省了，直接类名调用就可以了。可是抽象方法运行没意义。
```

### abstract可以修饰什么？abstract详解

abstract一般用来修饰类和方法。
1.abstract修饰类
abstract修饰类，会使得类变成抽象类，抽象类不能生成实例，但是可以作为对象变量声明的类型，也就是编译时类型。抽象类相当于类的半成品，需要子类继承并覆盖其中的方法。
注意：

- 抽象类虽然不能实例化，但是有自己的构造方法。
- 抽象类和接口(interface)有很大的不同之处，接口中不能有实例方法去实现业务逻辑，而抽象类可以有实例方法，并实现业务逻辑。
- 抽象类不能被final修饰，因为被final修饰的类无法被继承，而对于抽象类来说就是需要通过继承去实现抽象方法。

2.abstract修饰方法
abstract修饰方法会使得这个方法变成抽象方法，也就是只有声明，而没有实现，需要子类重写。
注意：

- 有抽象方法的类一定是抽象类，但是抽象类不一定有抽象方法。
- 父类是抽象类，其中有抽象方法，那么子类继承父类，并把父类中的所有抽象方法都实现了，子类才有创建对象实例的能力，否则子类也必须是抽象类。抽象类中可以有构造方法，子类在构造子类对象时需要调用父类(抽象类)的构造方法。
- 抽象方法不能用private修饰，因为抽象方法必须被子类重写，而private权限对于子类来说是不能访问的，所以就会产生矛盾。
- 抽象方法也不能用static修饰，如果用static修饰了，那么我们就可以直接通过类名调用了，而抽象方法压根没有主体，没有任何业务逻辑，这样就毫无意义了。

3.抽象类的多态性

```java
abstract class E{
    public abstract void show();// public abstract可以省略
}
```

然后其它类继承它通常为了实现它里面的方法。

```java
class F extends{
    void show(){
            写具体代码}
}
```

最后在主方法里定义一个父类引用指向子类对象，就会发生多态现象，比如

```java
E e = new F();
e.show();    
```

实际上调用了子类里面的new()方法。

4.抽象类的构造方法

```java
public abstract class Car {
	
 Car(){
  System.out.println("抽象方法无参构造函数");
 }
 Car(String a){
  System.out.println("抽象有参构造方法");
 }
 public void mothod1(){
  System.out.println(this.getClass());
  System.out.println("抽象类的实例方法");
 }
 public abstract void mothod2();
 }
/**
 * 自行车
 */
class Bicycle extends Car{
 Bicycle(){
  System.out.println("子类无参构造函数");
 }
 @Override
 public void mothod2() {//需要覆写抽象方法mothod2
 }
}
/**另一个包的测试类**/
public class Test {
 public static void main(String[] args) {
  Bicycle b = new Bicycle();
  b.mothod1();
 }
}
```

输出：

抽象方法无参构造函数
子类无参构造函数
class com.shaolin.service.impl.Bicycle
抽象类的实例方法

从上面的例子中可以看出：

- 抽象类是有构造方法的（当然如果我们不写，编译器会自动默认一个无参构造方法）。而且从结果来看，和普通的继承类一样，在new 一个子类对象时会优先调用父类（这里指的是抽象类Car）的构造器初始化，然后再调用子类的构造器。至此相信大家都会有这样一个疑问，为什么抽象方法不能实例化却有构造器呢？ 对于这个问题网上也中说纷纭，没有确定答案。
  我是这样想的：既然它也属于继承的范畴，那么当子类创建对象时必然要优先初始化父类的属性变量和实例方法，不然子类怎么继承和调用呢？而它本身不能实例化，因为它本身就是不确定的一个对象，如果它能被实例化，那么我们通过它的对象来调用它本身的抽象方法是不是有问题。所以不能实例化有在情理之中。因此大家只要记住这个规定就行。
- 对于抽象类中的非statci(静态)和非abstract(抽象)方法中的this关键字（静态方法中不能有关键字this，因为static方法可以直接由类名调用，this指代对象，没有实例化就没有对象，所以在static方法中不使用this）代表的是它的继承类，而非抽象类本身，这个好理解，因为抽象类本身不能被实例化。如果有多个继承类，谁调用this就代表谁。

抽象类有什么好处呢？

- 由于抽象类不能被实例化，最大的好处就是通过方法的覆盖来实现多态的属性。也就是运行期绑定
- 抽象类将事物的共性的东西提取出来，由子类继承去实现，代码易扩展、易维护。

### abstract和接口的区别

1.抽象类中可以有普通成员变量，接口中没有普通成员变量。
2.抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以是任意的，但是接口中定义的变量只是public static final类型，并且默认为public static final类型。
3.抽象类可以有构造方法，接口中不能有构造方法。
4.抽象类中可以包含静态方法，接口中不能有静态方法。这里注意，静态方法不要去重写，其次这里的静态方法一定要有具体实现，不能是抽象的。Java8中允许接口中包含静态方法了，可以用接口直接调用。
5.抽象类中抽象方法的访问类型可以是public，protected，但是接口中的抽象方法只能是public类型的，并且默认为public abstract类型的。
6.一个类可以实现多个接口，但是只能继承一个抽象类。

### 关于abstract的一些面试题

- 可以用抽象类来实现接口，这个时候就不需要实现接口的所有方法了。

```
1. Java抽象类可以有构造函数吗？
可以有，抽象类可以声明并定义构造函数。因为你不可以创建抽象类的实例，所以构造函数只能通过构造函数链调用（Java中构造函数链指的是从其他构造函数调用一个构造函数），例如，当你创建具体的实现类。现在一些面试官问，如果你不能对抽象类实例化那么构造函数的作用是什么？好吧，它可以用来初始化抽象类内部声明的通用变量，并被各种实现使用。另外，即使你没有提供任何构造函数，编译器将为抽象类添加默认的无参数的构造函数，没有的话你的子类将无法编译，因为在任何构造函数中的第一条语句隐式调用super()，Java中默认超类的构造函数。
2. Java抽象类可以实现接口吗？它们需要实现所有的方法吗？
可以，抽象类可以通过使用关键字implements来实现接口。因为它们是抽象的，所以它们不需要实现所有的方法。好的做法是，提供一个抽象基类以及一个接口来声明类型 。这样的例子是，java.util.List接口和相应的java.util.AbstractList抽象类。因为AbstractList实现了所有的通用方法，具体的实现像LinkedList和ArrayList不受实现所有方法的负担，它们可以直接实现List接口。这对两方面都很好，你可以利用接口声明类型的优点和抽象类的灵活性在一个地方实现共同的行为。Effective Java有个很好的章节，介绍如何使用Java的抽象类和接口，值得阅读。
3. Java抽象类可以是final的吗？
不可以，Java抽象类不能是final的。将它们声明为final的将会阻止它们被继承，而这正是使用抽象类唯一的方法。它们也是彼此相反的，关键字abstract强制继承类，而关键字final阻止类被扩张。在现实世界中，抽象表示不完备性，而final是用来证明完整性。底线是，你不能让你的Java类既abstract又final，同时使用，是一个编译时错误。
4. Java抽象类可以有static方法吗？
可以，丑娘类可以声明并定义static方法，没什么阻止这样做。但是，你必须遵守Java中将方法声明为static的准则，因为在面向对象的设计中是不受欢迎的，因为Java中的static方法是不可以被重载的。在抽象类中看到static方法是罕见的，但正如我所说的，如果你有很好的理由这样做的话，那没有什么可以阻止你。
5. 可以创建抽象类的实例吗？
不可以，你不能创建Java抽象类的实例，它们是不完全的。即使你的抽象类不包含任何抽象方法，你也不能对它实例化。将类声明为abstract的，就等你你告诉编译器，它是不完全的不应该被实例化。当一段代码尝试实例化一个抽象类时Java编译器会抛错误。
6. 抽象类必须有抽象方法吗？
不需要，抽象类有抽象方法不是强制性的。你只需要使用关键字abstract就可以将类声明为抽象类。编译器会强制所有结构的限制来适用于抽象类，例如，现在允许创建一些实例。是否在抽象类中有抽象方法是引起争论的。我的观点是，抽象类应该有抽象方法，因为这是当程序员看到那个类并做假设的第一件事。这也符合最小惊奇原则。
7. Java抽象类和接口有何不同？
很容易回答核心OOPS的概念，如抽象，封装，多态和继承，但是，当涉及到微妙点就是这样，候选人往往失手。
8. 何时选用抽象类而不是接口？
这是对之前抽象类和接口对比问题的后续。如果你知道语法差异，你可以很容易回答这个问题，因为它们可以令你做出抉择。当关心升级时，因为不可能在一个发布的接口中添加一个新方法，用抽象类会更好。类似地，如果你的接口中有很多方法，你对它们的实现感到很头疼，考虑提供一个抽象类作为默认实现。这是Java集合包中的模式，你可以使用提供默认实现List接口的AbstractList。
9. Java中的抽象方法是什么？
抽象方法是一个没有方法体的方法。你仅需要声明一个方法，不需要定义它并使用关键字abstract声明。Java接口中所有方法的声明默认是abstract的。这是抽象方法的例子
public void abstract printVersion();
现在，为了实现这个方法，你需要继承该抽象类并重载这个方法。
10. Java抽象类中可以包含main方法吗？
是的，抽象类可以包含main方法，它只是一个静态方法，你可以使用main方法执行抽象类，但不可以创建任何实例。
```

### 重写object对象的equasl方法时，通常还要重写哪个方法

```
hashcode(),构造方法
```

### 虚拟机栈知识点

```
（1）虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。换句话说，一个 Java线程的运行状态，由一个虚拟机栈来保存，所以虚拟机栈肯定是线程私有的，独有的，随着 线程的创建而创建 
（2）每一个被线程执行的方法，为该栈中的栈帧，即每个方法的执行对应一个栈帧 
（3）调用一个方法，就会向栈中压入一个栈帧；一个方法调用完成，就会把该栈帧从栈中弹出
栈桢
每个栈帧对应一个被调用的方法，可以理解为一个方法的运行空间。 每个栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、动态链接、方法返 回地址(Return Address)和附加信息。
```

### Jvm可达性分析，哪个对象可作为root

```
由GC Root出发，开始寻找，看看某个对象是否可达：类加载器、Thread、本地变量表、static成员、常用引用、本地方法栈中的变量等
```

### 组合索引会出现什么问题

```
组合索引的最左原则
```

### create Table user之后，user表中只有id列，那么可以插入重复id吗？

```
这个问题问的，当然要看有没有设置索引（唯一索引），有没有设置主键
```

###  写一个delete语句，删除表中重复元素

![image](https://user-images.githubusercontent.com/43489916/154788159-9cb6da6f-58b7-4a9c-b4f7-7d4de41589ac.png)

### object的方法有哪些

```
clone(),getClass(),registerNatives(),hashCode(),toString(),notify(),notifyAll(),wait(),finalize(),equals()
```

### Spring循环依赖

```
singletonObjects： 一级缓存，存储单例对象，Bean 已经实例化，初始化完成。
earlySingletonObjects： 二级缓存，存储 singletonObject，这个 Bean 实例化了，还没有初始化。
singletonFactories： 三级缓存，存储 singletonFactory。

所有被 Spring 管理的 Bean，最终都会存放在 singletonObjects 中，这里面存放的 Bean 是经历了所有生命周期的（除了销毁的生命周期），完整的，可以给用户使用的。
earlySingletonObjects 存放的是已经被实例化，但是还没有注入属性和执行 init 方法的 Bean。
singletonFactories 存放的是生产 Bean 的工厂。

为什么不能用三级缓存
Bean 都已经实例化了，为什么还需要一个生产 Bean 的工厂呢？这里实际上是跟 AOP 有关，如果项目中不需要为 Bean 进行代理，那么这个 Bean 工厂就会直接返回一开始实例化的对象，如果需要使用 AOP 进行代理，那么这个工厂就会发挥重要的作用了，这也是本文需要重点关注的问题之一。


```

![image](https://user-images.githubusercontent.com/43489916/154788176-82334a41-421b-4385-9141-986043f1ef64.png)

### Synchronized加在方法上和加在静态方法上的区别？

```
对于普通同步方法，锁是当前实例对象。
对于静态同步方法，锁是当前类的Class对象。
对于同步方法块，锁是Synchonized括号里配置的对象。
```

![image](https://user-images.githubusercontent.com/43489916/154788180-be08bd66-4fcd-4f84-ab45-6804c8bcb030.png)

### ReentrantLock和Synchronized区别

```
一个持有锁的线程，在释放锁之前，如果再次访问加了该同步锁的其他方法， 这个线程不需要再次争抢锁，只需要记录重入次数

使用方式
Synchronized可以修饰实例方法，静态方法，代码块。自动释放锁。
ReentrantLock一般需要try catch finally语句，在try中获取锁，在finally释放锁。需要手动释放锁。
实现方式
Synchronized是重量级锁。重量级锁需要将线程从内核态和用户态来回切换，耗费系统资源。
ReentrantLock是轻量级锁。采用cas+volatile管理线程，不需要线程切换，获取锁线程觉得自己肯定能成功，这是一种乐观的思想（可能失败）。
需要注意的是：这是两种不一样的思维方式，前者是被动阻塞悲观锁，状态是block，后者是主动的阻塞乐观锁，状态是wait。

公平和非公平
Synchronized只有非公平锁。
ReentrantLock提供公平和非公平两种锁，默认是非公平的。公平锁通过构造函数传递true表示。

可重入锁
Synchronized和ReentrantLock都是可重入的，Synchronized是本地方法是C++实现，而ReentrantLock是JUC包用Java实现。
在ReentrantLock中，重入次数用整形state表示。进入1次递增1次，出来1次递减1次。

可中断的
Synchronized是不可中断的。
ReentrantLock提供可中断和不可中断两种方式。其中lockInterruptibly方法表示可中断，lock方法表示不可中断。

条件队列
Synchronized只有一个等待队列。
ReentrantLock中一把锁可以对应多个条件队列。通过newCondition表示。

同步队列：多线程同时竞争一把锁失败被挂起的线程。
条件队列：正在执行的线程调用await/wait，从同步队列加入的线程会进入条件队列。正在执行线程调用signal/signalAll/notify/notifyAll，会将条件队列一个线程或多个线程加入到同步队列。
等待队列：和条件队列一个概念。
```

### 什么是线程同步？

```
线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。
```

### 怎么实现线程同步？

```java
1.同步方法 
即有synchronized关键字修饰的方法。 
由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。
代码如： 
public synchronized void save(){}
注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类 
    
2.同步代码块
即有synchronized关键字修饰的语句块。 
被该关键字修饰的语句块会自动被加上内置锁，从而实现同步
代码如： 
synchronized(object){ }
注：同步是一种高开销的操作，因此应该尽量减少同步的内容。 
通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。 
package com.xhj.thread;
    /**
     * 线程同步的运用
     */
    public class SynchronizedThread {
        class Bank {
            private int account = 100;
            public int getAccount() {
                return account;
            }
            /**
             * 用同步方法实现
             */
            public synchronized void save(int money) {
                account += money;
            }
            /**
             * 用同步代码块实现
             */
            public void save1(int money) {
                synchronized (this) {
                    account += money;
                }
            }
        }
        class NewThread implements Runnable {
            private Bank bank;
            public NewThread(Bank bank) {
                this.bank = bank;
            }
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    // bank.save1(10);
                    bank.save(10);
                    System.out.println(i + "账户余额为：" + bank.getAccount());
                }
            }
        }
        /**
         * 建立线程，调用内部类
         */
        public void useThread() {
            Bank bank = new Bank();
            NewThread new_thread = new NewThread(bank);
            System.out.println("线程1");
            Thread thread1 = new Thread(new_thread);
            thread1.start();
            System.out.println("线程2");
            Thread thread2 = new Thread(new_thread);
            thread2.start();
        }
        public static void main(String[] args) {
            SynchronizedThread st = new SynchronizedThread();
            st.useThread();
        }
    }
3.使用特殊域变量(volatile)实现线程同步
 volatile关键字为域变量的访问提供了一种免锁机制， 
 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， 
 因此每次使用该域就要重新计算，而不是使用寄存器中的值 
 volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 
 例如： 在上面的例子当中，只需在account前面加上volatile修饰，即可实现线程同步。 
代码实例： 
//只给出要修改的代码，其余代码与上同
        class Bank {
            //需要同步的变量加上volatile
            private volatile int account = 100;
            public int getAccount() {
                return account;
            }
            //这里不再需要synchronized
            public void save(int money) {
                account += money;
            }
        ｝
注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 用final域，有锁保护的域和volatile域可以避免非同步的问题。  

4.使用重入锁实现线程同步 
在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。 
ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力
ReenreantLock类的常用方法有：
ReentrantLock() : 创建一个ReentrantLock实例 
lock() : 获得锁 
unlock() : 释放锁    
注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用 
例如： 在上面例子的基础上，改写后的代码为: 代码实例： 
//只给出要修改的代码，其余代码与上同
        class Bank {
            private int account = 100;
            //需要声明这个锁
            private Lock lock = new ReentrantLock();
            public int getAccount() {
                return account;
            }
            //这里不再需要synchronized
            public void save(int money) {
                lock.lock();
                try{
                    account += money;
                }finally{
                    lock.unlock();
                }
            }
        ｝
注：关于Lock对象和synchronized关键字的选择： 
最好两个都不用，使用一种java.util.concurrent包提供的机制, 能够帮助用户处理所有与锁相关的代码。 
如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 
如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁 　　

5.使用局部变量实现线程同步     
如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， 
副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。
ThreadLocal 类的常用方法
ThreadLocal() : 创建一个线程本地变量 
get() : 返回此线程局部变量的当前线程副本中的值 
initialValue() : 返回此线程局部变量的当前线程的"初始值" 
set(T value) : 将此线程局部变量的当前线程副本中的值设置为value
例如： 
在上面例子基础上，修改后的代码为： 
代码实例： 
//只改Bank类，其余代码与上同
        public class Bank{
            //使用ThreadLocal类管理共享变量account
            private static ThreadLocal<Integer> account = new ThreadLocal<Integer>(){
                @Override
                protected Integer initialValue(){
                    return 100;
                }
            };
            public void save(int money){
                account.set(account.get()+money);
            }
            public int getAccount(){
                return account.get();
            }
        }
注：ThreadLocal与同步机制 
 a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。 
 b.前者采用以"空间换时间"的方法，后者采用以"时间换空间"的方式
    
6.使用阻塞队列实现线程同步
前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。 
使用javaSE5.0版本中新增的java.util.concurrent包将有助于简化开发。 
本小节主要是使用LinkedBlockingQueue<E>来实现线程的同步 
LinkedBlockingQueue<E>是一个基于已连接节点的，范围任意的blocking queue。 
LinkedBlockingQueue 类常用方法
LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue 
put(E e) : 在队尾添加一个元素，如果队列满则阻塞 
size() : 返回队列中的元素个数 
take() : 移除并返回队头元素，如果队列空则阻塞 
代码实例：
实现商家生产商品和买卖商品的同步
import java.util.Random;
import java.util.concurrent.LinkedBlockingQueue;
/**
 * 用阻塞队列实现线程同步 LinkedBlockingQueue的使用
 */
public class BlockingSynchronizedThread {
    /**
     * 定义一个阻塞队列用来存储生产出来的商品
     */
    private LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<Integer>();
    /**
     * 定义生产商品个数
     */
    private static final int size = 10;
    /**
     * 定义启动线程的标志，为0时，启动生产商品的线程；为1时，启动消费商品的线程
     */
    private int flag = 0;
 
    private class LinkBlockThread implements Runnable {
        @Override
        public void run() {
            int new_flag = flag++;
            System.out.println("启动线程 " + new_flag);
            if (new_flag == 0) {
                for (int i = 0; i < size; i++) {
                    int b = new Random().nextInt(255);
                    System.out.println("生产商品：" + b + "号");
                    try {
                        queue.put(b);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    System.out.println("仓库中还有商品：" + queue.size() + "个");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            } else {
                for (int i = 0; i < size / 2; i++) {
                    try {
                        int n = queue.take();
                        System.out.println("消费者买去了" + n + "号商品");
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    System.out.println("仓库中还有商品：" + queue.size() + "个");
                    try {
                        Thread.sleep(100);
                    } catch (Exception e) {
                        // TODO: handle exception
                    }
                }
            }
        }
    }
    public static void main(String[] args) {
        BlockingSynchronizedThread bst = new BlockingSynchronizedThread();
        LinkBlockThread lbt = bst.new LinkBlockThread();
        Thread thread1 = new Thread(lbt);
        Thread thread2 = new Thread(lbt);
        thread1.start();
        thread2.start();
    }
}
注：BlockingQueue<E>定义了阻塞队列的常用方法，尤其是三种添加元素的方法，我们要多加注意，当队列满时：
add()方法会抛出异常
offer()方法返回false
put()方法会阻塞
    
7.使用原子变量实现线程同步
需要使用线程同步的根本原因在于对普通变量的操作不是原子的。那么什么是原子操作呢？
原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作
即-这几种行为要么同时完成，要么都不完成。
在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，
使用该类可以简化线程同步。
其中AtomicInteger表可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，
但不能用于替换Integer；可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。
AtomicInteger类常用方法：
AtomicInteger(int initialValue) : 创建具有给定初始值的新的AtomicInteger
addAddGet(int dalta) : 以原子方式将给定值与当前值相加
get() : 获取当前值
代码实例：
只改Bank类，其余代码与上面第一个例子同
class Bank {
        private AtomicInteger account = new AtomicInteger(100);
 
        public AtomicInteger getAccount() {
            return account;
        }
 
        public void save(int money) {
            account.addAndGet(money);
        }
    }
补充--原子操作主要有：
对于引用变量和大多数原始变量(long和double除外)的读写操作；
对于所有使用volatile修饰的变量(包括long和double)的读写操作。
```

### 解释下什么是Join？

```
保证线程执行结果的可见性，本质是wait/notifyall
```

### InputStream和reader区别

```
一个是字节输入流，一个是字符输入流。对于中文如果是字节输入流可能会乱码，使用字符输入流
```

### 讲一下springBoot常用的注解

```
springbootapplication,configuration,enableautoconfiguration,componentscan,autowired,reference,component,repository,service,controller,resucontroller,requestmapping,scope,pathvaricable,requestparam,requestbody,value,configurationproperties,propertysource,参数校验的notempty,notblank,notnull,size....
```

### int范围，怎么计算的

```
-2的31方-2的31方-1   4字节，31位，一位符号位
```

### 常用的集合有哪些？简单说下

```
看之前课程的课件
```

### 合并两个链表，将两个链表合并成一个有序链表

```
修改指针即可
```

### 查出表中语文成绩第二的人.(语言描述)

```sql
Select max(成绩) as second from 表 where 科目=“语文”and second < (select max(成绩) from 表 where 科目=“语文”)
```

### 查出表中语文成绩并列前三的人.(语言描述)

```
先子查询去重成绩查出第三的成绩，然后在查出成绩比第三成绩大的数据
```

### 线程池如果没有使用，核心线程是否会消失

```
不会
1.线程池是怎么保证他的核心线程不释放 而一直等待任务的执行的呢？
2.我们一直理解的线程run方法执行完毕线程就销毁是不正确的？
3.还有我们为何通过设置allowCoreThreadTimeOut(true) 就能使核心线程销毁的呢？
答案：
1.线程阻塞
2.和那个关系不大
3.可以的
```

可以看看下面的源码分析：

从 exexute 方法开始：

```java
public void execute(Runnable command) {

        //如果提交的任务为null  抛出异常
        if (command == null)
            throw new NullPointerException();
        // 线程池是通过Integer类型的 高3位 表述当前线程池的状态RUNNING，SHUTDOWN，STOP，TIDYING，TERMINATED 。
        // 低29位表示当前线程的运行任务数量。然后通过位运算来计算运行状态和任务的数量。
        int c = ctl.get();
        //1.如果当前的任务数小于等于设置的核心线程大小，那么调用addWorker直接执行该任务
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        //2.如果当前的任务数大于设置的核心线程大小，而且当前的线程池状态时运行状态，那么向阻塞队列中添加任务
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        //3.如果向队列中添加失败，那么就新开启一个线程来执行该任务
        else if (!addWorker(command, false))
            reject(command);
    }
```

下面看看 addWorker 方法：

```java
private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        //一直尝试，
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);
            // Check if queue empty only if necessary.
            // 如果当前线程池的状态时SHUTDOWN，STOP，TIDYING，TERMINATED
            // 并且为SHUTDOWN状态时任务队列为空，那么就返回false
            // 原因：如果调用了shutdown方法，此时的线程池还会继续工作并且会在任务队列中的所有任务执行完成后才会结束线程池。
            if (rs >= SHUTDOWN &&
                    ! (rs == SHUTDOWN &&
                            firstTask == null &&
                            ! workQueue.isEmpty()))
                return false;
            for (;;) {
                //
                int wc = workerCountOf(c);
                //core是在execute方法中传的参数:true表示 核心线程，false表示最大线程
                //CAPACITY  可以理解为Integer的最大值  1左移29位再-1
                if (wc >= CAPACITY ||
                        wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;

                //如果增加任务数量成功那么退出这个循环执行下面的代码，否则继续
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            //
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    //再判断一次当前线程池的状态  避免在执行过程中线程时被使用者关闭
                    int rs = runStateOf(ctl.get());
                    if (rs < SHUTDOWN ||
                            (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        //向正在执行的任务队列(workers)中添加work
                        // 区别一下：workqueue 是等待执行的阻塞队列
                        workers.add(w);
                        int s = workers.size();

                        //记录曾经并发执行的最大任务个数
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        //添加任务成功
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    //如果任务添加成功那么开始执行任务
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```

下面看看 Worker 类的run 方法，实际是调用的ThreadPoolExecutor#runWorker方法：

```java
final void runWorker(ThreadPoolExecutor.Worker w) {
        Thread wt = Thread.currentThread();
        //得到worker对象中我们提交的任务
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            //如果当前任务为空  那么就从getTask中获得任务
            while (task != null || (task = getTask()) != null) {
                w.lock();
                if ((runStateAtLeast(ctl.get(), STOP) ||
                        (Thread.interrupted() &&
                                runStateAtLeast(ctl.get(), STOP))) &&
                        !wt.isInterrupted())
                    wt.interrupt();
                try {
                    //任务执行前调用的方法
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        //任务结束后调用的方法
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
```

下面看看 getTask 方法：

```java
private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);
            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }
            int wc = workerCountOf(c);
            // Are workers subject to culling?
            //从阻塞任务队列中取任务，如果设置了allowCoreThreadTimeOut(true)
            // 或者
            // 当前运行的任务数大于设置的核心线程数，那么timed =true
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

            if ((wc > maximumPoolSize || (timed && timedOut))
                    && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }
            try {
                //根据 timed true 或 false 来判断从哪里取任务，是否超时取任务
                Runnable r = timed ?
                        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                        // take()会一直阻塞，等待任务的添加。
                        workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```

到这里，所有的谜团都解开了。

### ArrayList和LinkedList区别（底层实现区别）

```
ArrayList 与 LinkedList 都是 List 接口的实现类，因此都实现了 List 的所有未实现的方法，只是实现的方式有所不同。

ArrayList 是基于动态数组数据结构的实现，访问元素速度优于 LinkedList。LinkedList 是基于链表数据结构的实现，占用的内存空间比较大，但在批量插入或删除数据时优于 ArrayList。

对于快速访问对象的需求，使用 ArrayList 实现执行效率上会比较好。需要频繁向集合中插入和删除元素时，使用 LinkedList 类比 ArrayList 类效果高。

不同的结构对应于不同的算法，有的考虑节省占用空间，有的考虑提高运行效率，对于程序员而言，它们就像是“熊掌”和“鱼肉”，不可兼得。高运行速度往往是以牺牲空间为代价的，而节省占用空间往往是以牺牲运行速度为代价的。
```

### ArrayList怎么删除元素？

```java
# remove方法：移除指定的元素
public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);
    // 记录要移动的元素的个数
    int numMoved = size - index - 1;
    if (numMoved > 0)
// 源数组 开始下标  目标数组 开始下标  长度
        System.arraycopy(elementData, index+1, elementData, index,numMoved);
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
```

### HashMap底层实现

![image](https://user-images.githubusercontent.com/43489916/154788223-a49d9a70-a8f7-4b0a-9ad5-cffe249c7f5b.png)

```
Jdk1.7及以前是采用数组+链表
Jdk1.8之后
采用数组+链表  或者  数组+红黑树方式进行元素的存储
存储在hashMap集合中的元素都将是一个Map.Entry的内部接口的实现

当数组的下标位是链表时,此时存储在该下标位置的内容将是Map.Entry的一个实现Node内部类对象
当数组的下标位是红黑树时,此时存储在该下标位置的内容将是Map.Entry的一个实现TreeNode内部类对象
链表长度>8转红黑树  默认初始长度16 负载因子0.75
```

### redis

#### 缓存雪崩

当某一时刻发生大规模的缓存失效的情况，会有大量的请求进来直接打到DB上面
![image.png](https://segmentfault.com/img/bVcOWUx)

##### 处理缓存雪崩

1.redis的key在同一时间大面积失效，可考虑:

- 在批量往`Redis`存数据的时候，把每个Key的失效时间都加个随机值，这样可以保证数据不会在同一时间大面积失效

```gauss
setRedis（Key，value，time + Math.random() * 10000）；
```

- 设置热点数据不设置过期时间，有更新操作就更新缓存就好了

2.redis挂了,可考虑:

- 使用集群缓存，保证缓存服务的高可用
  这种方案就是在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。
- 开启Redis持久化机制，尽快恢复缓存集群
  一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。

3.防止MySQL不挂，可考虑:

- ehcache本地缓存 + Hystrix限流&降级,避免MySQL被打死
  使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵。
  使用 Hystrix进行限流 & 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其 他剩余的 3000 请求就会走限流逻辑。然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。

流程图：
![image.png](https://segmentfault.com/img/bVcO3Y5)

#### 缓存穿透

用户不断发起请求缓存和数据库中都没有的数据。
我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。每次都能绕开Redis直接打到数据库，数据库也查不到，每次都这样，并发高点就容易崩掉了
![image.png](https://segmentfault.com/img/bVcOWZD)

##### 处理缓存穿透

1.接口层增加校验
比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id <=0的直接拦截等。

2.缓存空值
之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。那么我们就可以为这些key对应的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null。

3.布隆过滤器（Bloom Filter）
Bloom Filter是用于判断某个元素（key）是否存在于某个集合中。先把我们数据库的数据都加载到我们的过滤器中，在缓存之前在加一层BloomFilter，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存，然后查DB。

4.Nginx
对单个IP每秒访问次数超出阈值的IP都拉黑

流程图：
![image.png](https://segmentfault.com/img/bVcO3Zp)

#### 缓存击穿

缓存击穿是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。

1. 设置热点数据永远不过期

2. 互斥锁
   我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。
   其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。

### 线程私有区

```
本地方法栈，虚拟机栈(存栈帧，方法的状态)，程序计数器
```

### sql的优化

![image](https://upload-images.jianshu.io/upload_images/24674627-e6095528ed75c675?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 优化成本：硬件>系统配置>数据库表结构>SQL及索引。
- 优化效果：硬件<系统配置<数据库表结构

好了我们言归正传，首先，对于MySQL层优化我一般遵从五个原则：

1. 减少数据访问：设置合理的字段类型，启用压缩，通过索引访问等减少磁盘IO
2. 返回更少的数据：只返回需要的字段和数据分页处理 减少磁盘io及网络io
3. 减少交互次数：批量DML操作，函数存储等减少数据连接次数
4. 减少服务器CPU开销：尽量减少数据库排序操作以及全表查询，减少cpu 内存占用
5. 利用更多资源：使用表分区，可以增加并行操作，更大限度利用cpu资源

总结到SQL优化中，就三点:

- 最大化利用索引；
- 尽可能避免全表扫描；
- 减少无效数据的查询；

理解SQL优化原理 ，首先要搞清楚SQL执行顺序：

#### SELECT语句 - 语法顺序：

```sql
1. SELECT 
2. DISTINCT <select_list>
3. FROM <left_table>
4. <join_type> JOIN <right_table>
5. ON <join_condition>
6. WHERE <where_condition>
7. GROUP BY <group_by_list>
8. HAVING <having_condition>
9. ORDER BY <order_by_condition>
10.LIMIT <limit_number>
```

#### SELECT语句 - 执行顺序：

**FROM **  
<表名> # 选取表，将多个表数据通过笛卡尔积变成一个表。     
**ON **  
<筛选条件> # 对笛卡尔积的虚表进行筛选     
**JOIN**    
\# 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中    
**WHERE **   
\# 对上述虚表进行筛选   
**GROUP BY**   
<分组条件> # 分组   
\# 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的   
**HAVING **   
<分组筛选> # 对分组后的结果进行聚合筛选   
**SELECT**   
<返回数据列表> # 返回的单列必须在group by子句中，聚合函数除外   
**DISTINCT**       

#### 数据除重

**ORDER BY**
<排序条件> # 排序
**LIMIT**
<行数限制>

#### SQL优化策略

> 声明：以下SQL优化策略适用于数据量较大的场景下，如果数据量较小，没必要以此为准，以免画蛇添足。

##### 一、避免不走索引的场景

###### **1. 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。**

如下：

```
SELECT * FROM t WHERE username LIKE '%陈%'
```

优化方式：尽量在字段后面使用模糊查询。如下：

```
SELECT * FROM t WHERE username LIKE '陈%'
```

如果需求是要在前面使用模糊查询，

- 使用MySQL内置函数INSTR(str,substr) 来匹配，作用类似于java中的indexOf()，查询字符串出现的角标位置
- 使用FullText全文索引，用match against 检索
- 数据量较大的情况，建议引用ElasticSearch、solr，亿级数据量检索速度秒级
- 当表数据量较少（几千条儿那种），别整花里胡哨的，直接用like '%xx%'。

###### **2. 尽量避免使用in 和not in，会导致引擎走全表扫描。**

如下：

```
SELECT * FROM t WHERE id IN (2,3)` 
```

优化方式：如果是连续数值，可以用between代替。如下：

```
SELECT * FROM t WHERE id BETWEEN 2 AND 3
```

如果是子查询，可以用exists代替。如下：

```
-- 不走索引
select * from A where A.id in (select id from B);
-- 走索引
select * from A where exists (select * from B where B.id = A.id);
```

###### **3. 尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。**

如下：

```
SELECT * FROM t WHERE id = 1 OR id = 3
```

优化方式：可以用union代替or。如下：

```
SELECT * FROM t WHERE id = 1
   UNION
SELECT * FROM t WHERE id = 3
```

###### **4. 尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。**

如下：

```
SELECT * FROM t WHERE score IS NULL
```

优化方式：可以给字段添加默认值0，对0值进行判断。如下：

```
SELECT * FROM t WHERE score = 0` 
```

###### **5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。**

可以将表达式、函数操作移动到等号右侧。如下：

```
-- 全表扫描
SELECT * FROM T WHERE score/10 = 9
-- 走索引
SELECT * FROM T WHERE score = 10*9`
```

###### **6. 当数据量大时，避免使用where 1=1的条件。**

通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：

```
SELECT username, age, sex FROM T WHERE 1=1
```

优化方式：用代码拼装sql时进行判断，没 where 条件就去掉 where，有where条件就加 and。

###### **7. 查询条件不能用 <> 或者 !=**

使用索引列作为条件进行查询时，需要避免使用<>或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。

###### **8. where条件仅包含复合索引非前置列**

如下：复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列"key_part1"，按照MySQL联合索引的最左匹配原则，不会走联合索引。

```
select col1 from table where key_part2=1 and key_part3=2
```

###### **9. 隐式类型转换造成不使用索引**

如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。

```
select col1 from table where col_varchar=123;
```

###### **10. order by 条件要与where中条件一致，否则order by不会利用索引进行排序**

```
-- 不走age索引
SELECT * FROM t order by age;

-- 走age索引
SELECT * FROM t where age > 0 order by age;
```

对于上面的语句，数据库的处理顺序是：

- 第一步：根据where条件和统计信息生成执行计划，得到数据。
- 第二步：将得到的数据排序。当执行处理数据（order by）时，数据库会先查看第一步的执行计划，看order by 的字段是否在执行计划中利用了索引。如果是，则可以利用索引顺序而直接取得已经排好序的数据。如果不是，则重新进行排序操作。
- 第三步：返回排序后的数据。

当order by 中的字段出现在where条件中时，才会利用索引而不再二次排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作。

这个结论不仅对order by有效，对其他需要排序的操作也有效。比如group by 、union 、distinct等。

###### **11. 正确使用hint优化语句**

MySQL中可以使用hint指定优化器在执行时选择或忽略特定的索引。一般而言，处于版本变更带来的表结构索引变化，更建议避免使用hint，而是通过Analyze table多收集统计信息。但在特定场合下，指定hint可以排除其他索引干扰而指定更优的执行计划。

1. USE INDEX 在你查询语句中表名的后面，添加 USE INDEX 来提供希望 MySQL 去参考的索引列表，就可以让 MySQL 不再考虑其他可用的索引。例子: SELECT col1 FROM table USE INDEX (mod_time, name)...
2. IGNORE INDEX 如果只是单纯的想让 MySQL 忽略一个或者多个索引，可以使用 IGNORE INDEX 作为 Hint。例子: SELECT col1 FROM table IGNORE INDEX (priority) ...
3. FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。例子: SELECT col1 FROM table FORCE INDEX (mod_time) ...

在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。

例如：

```
SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC;
```

##### 二、SELECT语句其他优化

###### **1. 避免出现select** *

首先，select * 操作在任何类型数据库中都不是一个好的SQL编写习惯。

使用select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的I/O,内存和CPU消耗。

建议提出业务实际需要的列数，将指定列名以取代select *。

###### **2. 避免出现不确定结果的函数**

特定针对主从复制这类业务场景。由于原理上从库复制的是主库执行的语句，使用如now()、rand()、sysdate()、current_user()等不确定结果的函数很容易导致主库与从库相应的数据不一致。另外不确定值的函数,产生的SQL语句无法利用query cache。

###### **3.多表关联查询时，小表在前，大表在后。**

在MySQL中，执行 from 后的表关联查询是从左往右执行的（Oracle相反），第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。

例如：表1有50条数据，表2有30亿条数据；如果全表扫描表2，你品，那就先去吃个饭再说吧是吧。

###### **4. 使用表的别名**

当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。

###### **5. 用where字句替换HAVING字句**

避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。

where和having的区别：where后面不能使用组函数

###### **6.调整Where字句中的连接顺序**

MySQL采用从左往右，自上而下的顺序解析where子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。

##### 三、增删改 DML 语句优化

###### **1. 大批量插入数据**

如果同时执行大量的插入，建议使用多个值的INSERT语句(方法二)。这比使用分开INSERT语句快（方法一），一般情况下批量插入效率有几倍的差别。

方法一：

```
insert into T values(1,2); 

insert into T values(1,3); 

insert into T values(1,4);
```

方法二：

```
Insert into T values(1,2),(1,3),(1,4);
```

选择后一种方法的原因有三。

- 减少SQL语句解析的操作，MySQL没有类似Oracle的share pool，采用方法二，只需要解析一次就能进行数据的插入操作；
- 在特定场景可以减少对DB连接次数
- SQL语句较短，可以减少网络传输的IO。

###### **2. 适当使用commit**

适当使用commit可以释放事务占用的资源而减少消耗，commit后能释放的资源如下：

- 事务占用的undo数据块；
- 事务在redo log中记录的数据块；
- 释放事务施加的，减少锁争用影响性能。特别是在需要使用delete删除大量数据的时候，必须分解删除量并定期commit。

###### **3. 避免重复查询更新的数据**

针对业务中经常出现的更新行同时又希望获得改行信息的需求，MySQL并不支持PostgreSQL那样的UPDATE RETURNING语法，在MySQL中可以通过变量实现。

例如，更新一行记录的时间戳，同时希望查询当前记录中存放的时间戳是什么，简单方法实现：

```
Update t1 set time=now() where col1=1; 

Select time from t1 where id =1;
```

使用变量，可以重写为以下方式：

```
Update t1 set time=now () where col1=1 and @now: = now (); 

Select @now;
```

前后二者都需要两次网络来回，但使用变量避免了再次访问数据表，特别是当t1表数据量较大时，后者比前者快很多。

###### **4.查询优先还是更新（insert、update、delete）优先**

MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。

下面我们提到的改变调度策略的方法主要是针对只存在表锁的存储引擎，比如 MyISAM 、MEMROY、MERGE，对于Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。MySQL 的默认的调度策略可用总结如下：

1）写入操作优先于读取操作。

2）对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。

3）对某张数据表的多个读取操作可以同时地进行。MySQL 提供了几个语句调节符，允许你修改它的调度策略：

- LOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE；
- HIGH_PRIORITY关键字应用于SELECT和INSERT语句；
- DELAYED关键字应用于INSERT和REPLACE语句。

如果写入操作是一个 LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在 LOW_PRIORITY写入操作永远被阻塞的情况。

SELECT 查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的 SELECT 在正常的 SELECT 语句之前执行，因为这些语句会被写入操作阻塞。如果希望所有支持LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么 请使用--low-priority-updates 选项来启动服务器。通过使用 INSERTHIGH_PRIORITY 来把 INSERT 语句提高到正常的写入优先级，可以消除该选项对单个INSERT语句的影响。

##### 四、查询条件优化

###### **1. 对于复杂的查询，可以使用中间临时表 暂存数据**

###### **2. 优化group by语句**

默认情况下，MySQL 会对GROUP BY分组的所有值进行排序，如 “GROUP BY col1，col2，....;” 查询的方法如同在查询中指定 “ORDER BY col1，col2，...;” 如果显式包括一个包含相同的列的 ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。

因此，如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL禁止排序。例如：

```
SELECT col1, col2, COUNT(*) FROM table GROUP BY col1, col2 ORDER BY NULL ;
```

###### **3. 优化join语句**

MySQL中可以通过子查询来使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。

例子：假设要将所有没有订单记录的用户取出来，可以用下面这个查询完成：

```
SELECT col1 FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo )
```

如果使用连接(JOIN).. 来完成这个查询工作，速度将会有所提升。尤其是当 salesinfo表中对 CustomerID 建有索引的话，性能将会更好，查询如下：

```
SELECT col1 FROM customerinfo 
   LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID 
      WHERE salesinfo.CustomerID IS NULL
```

连接(JOIN).. 之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。

###### **4. 优化union查询**

MySQL通过创建并填充临时表的方式来执行union查询。除非确实要消除重复的行，否则建议使用union all。原因在于如果没有all这个关键词，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。

高效：

```
SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 

UNION ALL 

SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= 'TEST';
```

低效：

```
SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 

UNION 

SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= 'TEST';
```

###### **5.拆分复杂SQL为多个小SQL，避免大事务**

- 简单的SQL容易使用到MySQL的QUERY CACHE；
- 减少锁表时间特别是使用MyISAM存储引擎的表；
- 可以使用多核CPU。

###### **6. 使用truncate代替delete**

当删除全表中记录时，使用delete语句的操作会被记录到undo块中，删除记录也记录binlog，当确认需要删除全表时，会产生很大量的binlog并占用大量的undo数据块，此时既没有很好的效率也占用了大量的资源。

使用truncate替代，不会记录可恢复的信息，数据不能被恢复。也因此使用truncate操作有其极少的资源占用与极快的时间。另外，使用truncate可以回收表的水位，使自增字段值归零。

###### **7. 使用合理的分页方式以提高分页效率**

使用合理的分页方式以提高分页效率 针对展现等分页需求，合适的分页方式能够提高分页的效率。

案例1：

```
select * from t where thread_id = 10000 and deleted = 0 
   order by gmt_create asc limit 0, 15;
```

上述例子通过一次性根据过滤条件取出所有字段进行排序返回。数据访问开销=索引IO+索引全部记录结果对应的表数据IO。因此，该种写法越翻到后面执行效率越差，时间越长，尤其表数据量很大的时候。

适用场景：当中间结果集很小（10000行以下）或者查询条件复杂（指涉及多个不同查询字段或者多表连接）时适用。

案例2：

```
select t.* from (select id from t where thread_id = 10000 and deleted = 0
   order by gmt_create asc limit 0, 15) a, t 
      where a.id = t.id;
```

上述例子必须满足t表主键是id列，且有覆盖索引secondary key:(thread_id, deleted, gmt_create)。通过先根据过滤条件利用覆盖索引取出主键id进行排序，再进行join操作取出其他字段。数据访问开销=索引IO+索引分页后结果（例子中是15行）对应的表数据IO。因此，该写法每次翻页消耗的资源和时间都基本相同，就像翻第一页一样。

适用场景：当查询和排序字段（即where子句和order by子句涉及的字段）有对应覆盖索引时，且中间结果集很大的情况时适用。

##### 五、建表优化

###### **1. 在表中建立索引，优先考虑where、order by使用到的字段。**

###### **2. 尽量使用数字型字段**

（如性别，男：1 女：2），若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。

这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

###### **3. 查询数据量大的表 会造成查询缓慢。**

主要的原因是扫描行数过多。这个时候可以通过程序，分段分页进行查询，循环遍历，将结果合并处理进行展示。要查询100000到100050的数据，如下：

```
SELECT * FROM (SELECT ROW_NUMBER() OVER(ORDER BY ID ASC) AS rowid,* 
   FROM infoTab)t WHERE t.rowid > 100000 AND t.rowid <= 100050
```

###### **4. 用varchar/nvarchar 代替 char/nchar**

尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。

```
JOIN 按照功能大致分为如下三类：

INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。
LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。
RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。
```

### 怎么处理数据库中查回的10000条数据？数据量很大，分页查询很慢，有什么优化方案？

来源：cnblogs.com/youyoui/p/7851007.html

- 准备工作
- 一般分页查询
- 使用子查询优化
- 使用 id 限定优化
- 使用临时表优化
- 关于数据表的id说明

当需要从[数据库](https://cloud.tencent.com/solution/database?from=10680)查询的表有上万条记录的时候，一次性查询所有结果会变得很慢，特别是随着数据量的增加特别明显，这时需要使用分页查询。对于数据库分页查询，也有很多种方法和优化的点。下面简单说一下我知道的一些方法。

#### **准备工作**

为了对下面列举的一些优化进行测试，下面针对已有的一张表进行说明。

- 表名：order_history
- 描述：某个业务的订单历史表
- 主要字段：unsigned int id，tinyint(4) int type
- 字段情况：该表一共37个字段，不包含text等大型数据，最大为varchar(500)，id字段为索引，且为递增。
- 数据量：5709294

#### **一般分页查询**

一般的分页查询使用简单的 limit 子句就可以实现。limit 子句声明如下：

```javascript
SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset
```

LIMIT 子句可以被用于指定 SELECT 语句返回的记录数。需注意以下几点：

- 第一个参数指定第一个返回记录行的偏移量，注意从`0`开始
- 第二个参数指定返回记录行的最大数目
- 如果只给定一个参数：它表示返回最大的记录行数目
- 第二个参数为 -1 表示检索从某一个偏移量到记录集的结束所有的记录行
- 初始记录行的偏移量是 0(而不是 1)

下面是一个应用实例：

```javascript
select * from orders_history where type=8 limit 1000,10;
```

该条语句将会从表 orders_history 中查询`offset: 1000`开始之后的10条数据，也就是第1001条到第1010条数据（`1001 <= id <= 1010`）。

**数据表中的记录默认使用主键（一般为id）排序，上面的结果相当于：**

```javascript
select * from orders_history where type=8 order by id limit 10000,10;
```

针对这种查询方式，下面测试查询记录量对时间的影响：

```sql
select * from orders_history where type=8 limit 10000,1;
select * from orders_history where type=8 limit 10000,10;
select * from orders_history where type=8 limit 10000,100;
select * from orders_history where type=8 limit 10000,1000;
select * from orders_history where type=8 limit 10000,10000;
```

另外我还做了十来次查询，从查询时间来看，基本可以确定，在查询记录量低于100时，查询时间基本没有差距，随着查询记录量越来越大，所花费的时间也会越来越多。

针对查询偏移量的测试：

```sql
select * from orders_history where type=8 limit 100,100;
select * from orders_history where type=8 limit 1000,100;
select * from orders_history where type=8 limit 10000,100;
select * from orders_history where type=8 limit 100000,100;
select * from orders_history where type=8 limit 1000000,100;
```

随着查询偏移的增大，尤其查询偏移大于10万以后，查询时间急剧增加。

**这种分页查询方式会从数据库第一条记录开始扫描，所以越往后，查询速度越慢，而且查询的数据越多，也会拖慢总查询速度。**

#### **使用子查询优化**

这种方式先定位偏移位置的 id，然后往后查询，这种方式适用于 id 递增的情况。

```javascript
select * from orders_history where type=8 limit 100000,1;

select id from orders_history where type=8 limit 100000,1;

select * from orders_history where type=8 and
id>=(select id from orders_history where type=8 limit 100000,1)
limit 100;

select * from orders_history where type=8 limit 100000,100;
```

针对上面的查询需要注意：

- 比较第1条语句和第2条语句：使用 select id 代替 select * 速度增加了3倍
- 比较第2条语句和第3条语句：速度相差几十毫秒
- 比较第3条语句和第4条语句：得益于 select id 速度增加，第3条语句查询速度增加了3倍

这种方式相较于原始一般的查询方法，将会增快数倍。

#### **使用 id 限定优化**

这种方式假设数据表的id是**连续递增**的，则我们根据查询的页数和查询的记录数可以算出查询的id的范围，可以使用 id between and 来查询：

```javascript
select * from orders_history where type=2
and id between 1000000 and 1000100 limit 100;
```

查询时间：15ms 12ms 9ms

这种查询方式能够极大地优化查询速度，基本能够在几十毫秒之内完成。限制是只能使用于明确知道id的情况，不过一般建立表的时候，都会添加基本的id字段，这为分页查询带来很多便利。

还可以有另外一种写法：

```javascript
select * from orders_history where id >= 1000001 limit 100;
```

当然还可以使用 in 的方式来进行查询，这种方式经常用在多表关联的时候进行查询，使用其他表查询的id集合，来进行查询：

```javascript
select * from orders_history where id in
(select order_id from trade_2 where goods = 'pen')
limit 100;
```

这种 in 查询的方式要注意：某些 mysql 版本不支持在 in 子句中使用 limit。

#### **使用临时表优化**

这种方式已经不属于查询优化，这儿附带提一下。

对于使用 id 限定优化中的问题，需要 id 是连续递增的，但是在一些场景下，比如使用历史表的时候，或者出现过数据缺失问题时，可以考虑使用临时存储的表来记录分页的id，使用分页的id来进行 in 查询。这样能够极大的提高传统的分页查询速度，尤其是数据量上千万的时候。

#### **关于数据表的id说明**

一般情况下，在数据库中建立表的时候，强制为每一张表添加 id 递增字段，这样方便查询。

如果像是订单库等数据量非常庞大，一般会进行分库分表。这个时候不建议使用数据库的 id 作为唯一标识，而应该使用分布式的高并发唯一 id 生成器来生成，并在数据表中使用另外的字段来存储这个唯一标识。

使用先使用范围查询定位 id （或者索引），然后再使用索引进行定位数据，能够提高好几倍查询速度。即先 select id，然后再 select *；

### 幂等性问题

#### **幂等性概念**

幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。

在编程中.一个幂等操作的特点是**其任意多次执行所产生的影响均与一次执行的影响相同**。幂等函数，或幂等方法，是指可以**使用相同参数重复执行，并能获得相同结果的函数**。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数.

**更复杂的操作幂等保证是利用唯一交易号(流水号)实现.**

#### **技术方案**

##### **1. 查询操作**

查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作

##### **2. 删除操作**

删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)

##### **3.唯一索引**

数据库唯一主键的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。

使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键，这样才能能保证在分布式环境下 ID 的全局唯一性。

**适用操作：**

- 插入操作
- 删除操作

**使用限制：**

- 需要生成全局唯一主键 ID；

**主要流程：**

![img](https://img-blog.csdnimg.cn/img_convert/85f2bdf09380a48598dd1d806f713591.png)

主要流程：

- ① 客户端执行创建请求，调用服务端接口。
- ② 服务端执行业务逻辑，生成一个分布式 ID，将该 ID 充当待插入数据的主键，然后执数据插入操作，运行对应的 SQL 语句。
- ③ 服务端将该条数据插入数据库中，如果插入成功则表示没有重复调用接口。如果抛出主键重复异常，则表示数据库中已经存在该条记录，返回错误信息到客户端。

**要点：唯一索引或唯一组合索引来防止新增数据存在脏数据**（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）

##### **4. token机制**

针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用 Token 的机制实现防止重复提交。简单的说就是调用方在调用接口的时候先向后端请求一个全局 ID（Token），请求的时候携带这个全局 ID 一起请求（Token 最好将其放到 Headers 中），后端需要对这个 Token 作为 Key，用户信息作为 Value 到 Redis 中进行键值内容校验，如果 Key 存在且 Value 匹配就执行删除命令，然后正常执行后面的业务逻辑。如果不存在对应的 Key 或 Value 不匹配就返回重复执行的错误信息，这样来保证幂等操作

**使用限制：**

- 需要生成全局唯一 Token 串；
- 需要使用第三方组件 Redis 进行数据效验；

**主要流程：**

![img](https://img-blog.csdnimg.cn/img_convert/66b9498a46469a3b9ce1497a8c8b2afc.png)

- ① 服务端提供获取 Token 的接口，该 Token 可以是一个序列号，也可以是一个分布式 ID 或者 UUID 串。
- ② 客户端调用接口获取 Token，这时候服务端会生成一个 Token 串。
- ③ 然后将该串存入 Redis 数据库中，以该 Token 作为 Redis 的键（注意设置过期时间）。
- ④ 将 Token 返回到客户端，客户端拿到后应存到表单隐藏域中。
- ⑤ 客户端在执行提交表单时，把 Token 存入到 Headers 中，执行业务请求带上该 Headers。
- ⑥ 服务端接收到请求后从 Headers 中拿到 Token，然后根据 Token 到 Redis 中查找该 key 是否存在。
- ⑦ 服务端根据 Redis 中是否存该 key 进行判断，如果存在就将该 key 删除，然后正常执行业务逻辑。如果不存在就抛异常，返回重复提交的错误信息。

> 注意，在并发情况下，执行 Redis 查找数据与删除需要保证原子性，否则很可能在并发下无法保证幂等性。其实现方法可以使用分布式锁或者使用 Lua 表达式来注销查询与删除操作。

##### **5. 悲观锁**

获取数据的时候加锁获取 select * from table_xxx where id='xxx' **for update**;注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的 悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用

##### **6. 乐观锁**

###### **1）. 通过版本号实现**

数据库乐观锁方案一般只能适用于执行“更新操作”的过程，我们可以提前在对应的数据表中多添加一个字段，充当当前数据的版本标识。这样每次对该数据库该表的这条数据执行更新时，都会将该版本标识作为一个条件，值为上次待更新数据中的版本标识的值。

**描述示例：**

![img](https://img-blog.csdnimg.cn/img_convert/76bdb6ce8943267c8ef3efc05b865a71.png)

为了每次执行更新时防止重复更新，确定更新的一定是要更新的内容，我们通常都会添加一个 version 字段记录当前的记录版本，这样在更新时候将该值带上，那么只要执行更新操作就能确定一定更新的是某个对应版本下的信息。

这样每次执行更新时候，都要指定要更新的版本号，如下操作就能准确更新 version=5 的信息：

```go
UPDATE my_table SET price=price+50,version=version+1 WHERE id=1 AND version=5
```

上面 WHERE 后面跟着条件 id=1 AND version=5 被执行后，id=1 的 version 被更新为 6，所以如果重复执行该条 SQL 语句将不生效，因为 id=1 AND version=5 的数据已经不存在，这样就能保住更新的幂等，多次更新对结果不会产生影响。

乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。

乐观锁的实现方式多种多样可以通过version或者其他状态条件：

###### **2）. 通过条件限制**

update tablexxx set avaiamount=avaiamount-#subAmount# where avaiamount-#subAmount# >= 0

要求：quality-#subQuality# >= ，这个情景适合不用版本号，只更新是做[数据安全](https://cloud.tencent.com/solution/data_protection?from=10680)校验，适合库存模型，扣份额和回滚份额，性能更高

**注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表**

##### **7. 分布式锁**

还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。

**要点：**某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)

##### **8. select + insert**

并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了注意：**核心高并发流程不要用这种方法**

##### **9. 对外提供接口的api如何保证幂等如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)**

重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一**个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引**，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。

### 什么是泛型，谈谈你对泛型的理解

```
我们在申明ArrayList时,指定了存储类型为String 所以在编译阶段,我们存入其他类型的元素,就会报出错误.即我们的申明强制的指定了ArrayList集合中存储的元素只能是指定的String类型.这就是泛型使用的本质意义所在,指定参数化类型.

在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。
```

#### **无边界通配符?**

前面的内容.我们知道ArrayList 是典型的泛型类.即可以限制存储的元素的元素类型.ArrayList<String>指定存入的元素时string. ArrayList<Integer>指定存储元素为Integer类型. 但是如果只有我们使用的时候才能明确知道存入类型时.我们可以使用ArrayList<?> 来表示通用的类型.

案例中的 ***?*** 代表着限定通用类型. 或者这么理解.代表可变的参数类型.

#### **上界通配符**

 ?  extends  Number  代表从Number往下的子类或者孙类对象都是可以的..

#### **下界通配符**

***?  super  Integer***  代表从Integer 到 Object 所有对象都是可以的.

#### 泛型的具体使用

泛型跟我们的成员属性一样,需要先声明才能使用.泛型的声明采用 <> 进行声明.

申明一般约定采用单个大写字母表示.常用的有 K  E  T  V 等等字符

```java
public <T> T demo(T t){}
```

### Java反射相关知识

```
指在Java程序运行状态中，
1.对于给定的一个类(Class)对象，可以获得这个类(Class)对象的所有属性和方法；
2.对于给定的一个对象(new XXXClassName<? extends Object>)，都能够调用它的任意一个属性和方法.
	
这种动态获取类的内容以及动态调用对象的方法和获取属性的机制.就叫做JAVA的反射机制

优势
增加程序的灵活性，避免将固有的逻辑程序写死到代码里
代码简洁,可读性强，可提高代码的复用率
缺点
相较直接调用在量大的情景下反射性能下降
内部暴露和安全隐患

反射到底慢在哪些地方：
寻找类Class字节码的过程
安全管理机制的权限验证等等
若需要调用native方法调用时JNI接口的使用
```

#### **反射的基本操作**

##### 获取类对象的四种方式

```java
Class clazz = Person.class;
Class clazz2 = new Person().getClass();
Class clazz3 = Class.forName("com.example.demo.fashe.Person");
Class clazz4 = Demo02.class.getClassLoader().loadClass("com.example.demo.fashe.Person");
```

##### 基本信息操作

```java
// 获取类的相关结构
int modifier = clazz.getModifiers(); // 获取类修饰符
Package aPackage = clazz.getPackage(); // 获取类包名
String fullClassName = clazz.getName(); // 获取类的全路径名称
String simpleName = clazz.getSimpleName(); // 获取类的简单名称
ClassLoader classLoader = clazz.getClassLoader(); // 获取类加载器
Class[] interfaces = clazz.getInterfaces(); // 获取类实现的接口列表
Class superclass = clazz.getSuperclass(); // 获取类的父类
Annotation[] annotations = clazz.getAnnotations(); // 获取类的注解信息
```

#####  **类的属性操作**

```java
Person person = (Person) clazz.newInstance();
// 获取类中所有的共有字段 包含继承的字段
Field[] fields = clazz.getFields();
// 获取类中定义的字段 内部
Field[] declaredFields = clazz.getDeclaredFields();
// 获取指定名称的类中定义的字段
Field nameField = clazz.getDeclaredField("name");
// 获取字段的修饰符
int modifiers = nameField.getModifiers();
// 指定字段强制访问
nameField.setAccessible(true);
// 修改字段你的值
nameField.set(person,"咕泡");
// 静态字段赋值
nameField.set(null,"静态字段赋值");
```

##### **类的方法操作**

```java
/ 获取类中的所有的共有的方法 继承
Method[] methods = clazz.getMethods();
// 获取类中的定义的方法
Method[] declaredMethods = clazz.getDeclaredMethods();
// 获取类中指定名称和参数的公有方法
Method say = clazz.getMethod("say", String.class);
// 获取类中定义的指定名称和参数的方法
Method say1 = clazz.getDeclaredMethod("say");
// 获取方法的修饰符
int modifiers1 = say.getModifiers();
// 指定对象进行成员方法的调用
Object 咕泡666 = say.invoke(person, "咕泡666");
say.setAccessible(true);// 指定方法的强制执行
// 静态方法调用
say.invoke(null);
```

##### **构造器的操作**

```java
Constructor[] cons = clazz.getConstructors();            //获取类中所有的公有构造器
Constructor[] cons1 = clazz.getDeclaredConstructors();       //获取类中所有的构造器
Constructor conNoParam= clazz.getDeclaredConstructor();       //获取类中无参的构造器
Constructor con= clazz.getDeclaredConstructor(String.class,String.class);   //获取类中有参构造
int modifers = con.getModifiers();             //获取构造器的修饰符
conNoParam.newInstance();              //构造器实例对象
con.setAccessible(true);                  //指定方法的强制访问
con.newInstance("abc","bbb");              //有参构造调用
Person.class.newInstance();                //class直接调用默认无参构造
```

##### **单例模式**

通过反射可以创建多个实例，从而破坏单例的设计

通过反射 调用私有的构造器来创建对象，从而破坏单例设计   

那么如何防止这种破坏呢，其实很简单我们只需要在私有构造中加个判断就可以了，如下

```java
private  PersonSingle(){
    if(PersonSingle.instance != null){
        throw new RuntimeException("实例已经创建，不允许再创建了...");
    }
}
```

### 线程池参数怎么设置

https://sbfly-j.github.io/2022/01/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0/

### 单体应用和微服务的区别

**1.分工不同**

- 以前我们通常是一个有规模的团队围绕一个单体应用工作，可能是一人一个模块；
- 微服务架构可以为软件开发提供不同的方法，把传统模式下的单体应用拆分成独立的服务，从而可以单独开发、单独部署、单独维护，在微服务架构下可能是一人一个系统。

**2. 存储方式不同**

- 单体架构所有的模块都共用一个数据库，存储方式比较单一；
- 微服务每个模块都可以使用不同的存储方式（比如有的用redis，有的用mysql等），数据库也是单个模块对应自己的数据库。

**3.部署方式不同**

- 在单体应用中，每次功能的变更或缺陷的修复都会导致需要重新部署整个应用；
- 微服务架构服务可独立部署，并且可以独立于其他服务进行扩展，如果部署得当，基于微服务的架构可以帮助业务避免欠下技术债务，以及大幅提高效率的重大价值。

**4.容灾不同**

- 当某一组建发生故障时，在单一进程的传统架构下，故障很有可能在进程内扩散，形成应用全局性的不可用。
- 在微服务架构下，故障会被隔离在单个服务中。好的微服务可以隔离故障避免服务整体down掉，坏的微服务设计仍然可以因为一个子服务出现问题导致连锁反应。

**5. 开发模式不同**

- 单体架构所有的模块开发所使用的技术一样，开发模式比较受限；
- 微服务每个模块都可以使用不同的开发技术，开发模式更灵活；

### new HashTable()的创建过程

#### 概述

和 HashMap 一样，Hashtable 也是一个散列表，它存储的内容是键值对。

Hashtable 在 Java 中的定义为：

```java
public class Hashtable<K,V>  
    extends Dictionary<K,V>  
    implements Map<K,V>, Cloneable, java.io.Serializable{}
```

从源码中，我们可以看出，Hashtable 继承于 Dictionary 类，实现了 Map, Cloneable, java.io.Serializable接口。其中Dictionary类是任何可将键映射到相应值的类（如 Hashtable）的抽象父类，每个键和值都是对象（源码注释为：The `Dictionary` class is the abstract parent of any class, such as `Hashtable`, which maps keys to values. Every key and every value is an object.）。但在这一点我开始有点怀疑，因为我查看了HashMap以及TreeMap的源码，都没有继承于这个类。不过当我看到注释中的解释也就明白了，其 Dictionary 源码注释是这样的：NOTE: This class is obsolete. New implementations should implement the Map interface, rather than extending this class. 该话指出 Dictionary 这个类过时了，新的实现类应该实现Map接口。

#### Hashtable 源码解读

##### 成员变量

Hashtable是通过"拉链法"实现的哈希表。它包括几个重要的成员变量：table, count, threshold, loadFactor, modCount。

- table是一个 Entry[] 数组类型，而 Entry实际上就是一个单向链表。哈希表的"key-value键值对"都是存储在Entry数组中的。
- count 是 Hashtable 的大小，它是 Hashtable 保存的键值对的数量。
- threshold 是 Hashtable 的阈值，用于判断是否需要调整 Hashtable 的容量。threshold 的值="容量*加载因子"。
- loadFactor 就是加载因子。
- modCount 是用来实现 fail-fast 机制的。

关于变量的解释在源码注释中都有，最好还是应该看英文注释。

```java
/**
     * The hash table data.
     */
    private transient Entry<K,V>[] table;

    /**
     * The total number of entries in the hash table.
     */
    private transient int count;

    /**
     * The table is rehashed when its size exceeds this threshold.  (The
     * value of this field is (int)(capacity * loadFactor).)
     *
     * @serial
     */
    private int threshold;

    /**
     * The load factor for the hashtable.
     *
     * @serial
     */
    private float loadFactor;

    /**
     * The number of times this Hashtable has been structurally modified
     * Structural modifications are those that change the number of entries in
     * the Hashtable or otherwise modify its internal structure (e.g.,
     * rehash).  This field is used to make iterators on Collection-views of
     * the Hashtable fail-fast.  (See ConcurrentModificationException).
     */
    private transient int modCount = 0;
```

#### 构造方法

Hashtable 一共提供了 4 个构造方法：

- `public Hashtable(int initialCapacity, float loadFactor)`： 用指定初始容量和指定加载因子构造一个新的空哈希表。useAltHashing 为 boolean，其如果为真，则执行另一散列的字符串键，以减少由于弱哈希计算导致的哈希冲突的发生。
- `public Hashtable(int initialCapacity)`：用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。
- `public Hashtable()`：默认构造函数，容量为 11，加载因子为 0.75。
- `public Hashtable(Map<? extends K, ? extends V> t)`：构造一个与给定的 Map 具有相同映射关系的新哈希表。

```java
/**
     * Constructs a new, empty hashtable with the specified initial
     * capacity and the specified load factor.
     *
     * @param      initialCapacity   the initial capacity of the hashtable.
     * @param      loadFactor        the load factor of the hashtable.
     * @exception  IllegalArgumentException  if the initial capacity is less
     *             than zero, or if the load factor is nonpositive.
     */
    public Hashtable(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal Load: "+loadFactor);

        if (initialCapacity==0)
            initialCapacity = 1;
        this.loadFactor = loadFactor;
        table = new Entry[initialCapacity];
        threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
        useAltHashing = sun.misc.VM.isBooted() &&
                (initialCapacity >= Holder.ALTERNATIVE_HASHING_THRESHOLD);
    }

    /**
     * Constructs a new, empty hashtable with the specified initial capacity
     * and default load factor (0.75).
     *
     * @param     initialCapacity   the initial capacity of the hashtable.
     * @exception IllegalArgumentException if the initial capacity is less
     *              than zero.
     */
    public Hashtable(int initialCapacity) {
        this(initialCapacity, 0.75f);
    }

    /**
     * Constructs a new, empty hashtable with a default initial capacity (11)
     * and load factor (0.75).
     */
    public Hashtable() {
        this(11, 0.75f);
    }

    /**
     * Constructs a new hashtable with the same mappings as the given
     * Map.  The hashtable is created with an initial capacity sufficient to
     * hold the mappings in the given Map and a default load factor (0.75).
     *
     * @param t the map whose mappings are to be placed in this map.
     * @throws NullPointerException if the specified map is null.
     * @since   1.2
     */
    public Hashtable(Map<? extends K, ? extends V> t) {
        this(Math.max(2*t.size(), 11), 0.75f);
        putAll(t);
    }
```

#### put 方法

put 方法的整个流程为：

1. 判断 value 是否为空，为空则抛出异常；
2. 计算 key 的 hash 值，并根据 hash 值获得 key 在 table 数组中的位置 index，如果 table[index] 元素不为空，则进行迭代，如果遇到相同的 key，则直接替换，并返回旧 value；
3. 否则，我们可以将其插入到 table[index] 位置。

我在下面的代码中也进行了一些注释：

```java
public synchronized V put(K key, V value) {
        // Make sure the value is not null确保value不为null
        if (value == null) {
            throw new NullPointerException();
        }

        // Makes sure the key is not already in the hashtable.
        //确保key不在hashtable中
        //首先，通过hash方法计算key的哈希值，并计算得出index值，确定其在table[]中的位置
        //其次，迭代index索引位置的链表，如果该位置处的链表存在相同的key，则替换value，返回旧的value
        Entry tab[] = table;
        int hash = hash(key);
        int index = (hash & 0x7FFFFFFF) % tab.length;
        for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) && e.key.equals(key)) {
                V old = e.value;
                e.value = value;
                return old;
            }
        }

        modCount++;
        if (count >= threshold) {
            // Rehash the table if the threshold is exceeded
            //如果超过阀值，就进行rehash操作
            rehash();

            tab = table;
            hash = hash(key);
            index = (hash & 0x7FFFFFFF) % tab.length;
        }

        // Creates the new entry.
        //将值插入，返回的为null
        Entry<K,V> e = tab[index];
        // 创建新的Entry节点，并将新的Entry插入Hashtable的index位置，并设置e为新的Entry的下一个元素
        tab[index] = new Entry<>(hash, key, value, e);
        count++;
        return null;
    }
```

通过一个实际的例子来演示一下这个过程：

假设我们现在Hashtable的容量为5，已经存在了(5,5)，(13,13)，(16,16)，(17,17)，(21,21)这 5 个键值对，目前他们在Hashtable中的位置如下：

![图1](https://wiki.jikexueyuan.com/project/java-collection/images/hashtable1.png)

现在，我们插入一个新的键值对，put(16,22)，假设key=16的索引为1.但现在索引1的位置有两个Entry了，所以程序会对链表进行迭代。迭代的过程中，发现其中有一个Entry的key和我们要插入的键值对的key相同，所以现在会做的工作就是将newValue=22替换oldValue=16，然后返回oldValue=16.

![图2](https://wiki.jikexueyuan.com/project/java-collection/images/hashtable2.png)

然后我们现在再插入一个，put(33,33)，key=33的索引为3，并且在链表中也不存在key=33的Entry，所以将该节点插入链表的第一个位置。

![图3](https://wiki.jikexueyuan.com/project/java-collection/images/hashtable3.png)

#### get 方法

相比较于 put 方法，get 方法则简单很多。其过程就是首先通过 hash()方法求得 key 的哈希值，然后根据 hash 值得到 index 索引（上述两步所用的算法与 put 方法都相同）。然后迭代链表，返回匹配的 key 的对应的 value；找不到则返回 null。

```java
public synchronized V get(Object key) {
        Entry tab[] = table;
        int hash = hash(key);
        int index = (hash & 0x7FFFFFFF) % tab.length;
        for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) && e.key.equals(key)) {
                return e.value;
            }
        }
        return null;
    }
```

#### Hashtable 遍历方式

Hashtable 有多种遍历方式：

```java
//1、使用keys()
Enumeration<String> en1 = table.keys();
    while(en1.hasMoreElements()) {
    en1.nextElement();
}

//2、使用elements()
Enumeration<String> en2 = table.elements();
    while(en2.hasMoreElements()) {
    en2.nextElement();
}

//3、使用keySet()
Iterator<String> it1 = table.keySet().iterator();
    while(it1.hasNext()) {
    it1.next();
}

//4、使用entrySet()
Iterator<Entry<String, String>> it2 = table.entrySet().iterator();
    while(it2.hasNext()) {
    it2.next();
}
```

#### Hashtable 与 HashMap 的简单比较

1. HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。
2. HashMap 的 key 和 value 都允许为 null，而 Hashtable 的 key 和 value 都不允许为 null。HashMap 遇到 key 为 null 的时候，调用 putForNullKey 方法进行处理，而对 value 没有处理；Hashtable遇到 null，直接返回 NullPointerException。
3. Hashtable 方法是同步，而HashMap则不是。我们可以看一下源码，Hashtable 中的几乎所有的 public 的方法都是 synchronized 的，而有些方法也是在内部通过 synchronized 代码块来实现。所以有人一般都建议如果是涉及到多线程同步时采用 HashTable，没有涉及就采用 HashMap，但是在 Collections 类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的 Map 对象，并把它作为一个封装的对象来返回。

### Explain查看sql执行计划

我们可以在查询语句前面加上`EXPLAIN`关键字来查看这个查询的**执行计划**。例如

```text
mysql> EXPLAIN SELECT 1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
1 row in set, 1 warning (0.01 sec)
```

可以看到，执行计划包含很多输出列，我们先简单过一下各列的大致作用，后面再进行详细讲解。

| 列名          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| id            | 在一个大的查询语句中每个`SELECT`关键字都对应一个唯一的id     |
| select_type   | `SELECT`关键字对应的那个查询的类型                           |
| table         | 表名                                                         |
| partitions    | 匹配的分区信息                                               |
| type          | 针对单表的访问方法                                           |
| possible_keys | 可能应用在这个表的索引，可以会一个或者多个，不一定是实际查询使用的索引。 |
| key           | 查询中实际使用的索引，如果为null表示没有使用索引。如果是覆盖索引，则只显示在key中。 |
| key_len       | 表示索引字段的最大可能长度，并不是实际的长度，它是根据表定义得到的，而不是通过表检索得到的。长度越短越好。 |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息       |
| rows          | 根据表的信息和索引使用情况，大致估算的查找到所需的记录需要扫描的行数。越小越好。 |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比                 |
| Extra         | 一些额外的信息                                               |

#### id

id表示select查询语句的执行顺序或者是操作表的执行顺序。

id的值有二种情况：

1. id相同，表示执行的顺序是由上至下
2. id不同，id的序号会是递增的，id的值越大表示优先级越高，越先被执行。

#### select_type

- SIMPLE：简单的查询，不包含子查询和UNION。
- PRIMARY：如果查询的语句中包含了复杂的子查询，那么最外层的查询被标记为PRIMARY。
- SUBQUERY：select或者where中的子查询。
- DERIVED：from列表中的子查询生成的衍生表查询。
- UNION：联合查询。
- UNION RESULT：从UNION表获取结果的查询。

#### type

表示查询使用了哪种类型，它的值域：ALL、index、range、ref、eq_ref、const、system。这是我们优化时重点关注的一个指标。

从最好到最差排序：

system>const>eq_ref>ref>range>index>ALL。

阿里巴巴SQL优化规范：

- 【推荐】 SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是const最好。
- 说明：
- 1)const 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。
- 2)ref 指的是使用普通的索引(normal index)。
- 3)range 对索引进行范围检索。

system：表中只有一行记录的查询，类似系统表。

eq_ref：多表时唯一索引扫描，对于每一个索引，表中只有一行记录相匹配。

index：索引物理文件全扫描，速度比较慢，比全表扫描性能好一点。

ALL：全表扫描。

#### ref

表示索引的哪一列被使用了，可能是个常数。哪些列或者常量被用于查找索引列上的值。

#### Extra

阿里巴巴SQL优化规范：

- 【推荐】利用覆盖索引来进行查询操作，避免回表。
- 说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗?目录浏览一下就好，这个目录就是起到覆盖索引的作用。
- 正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现：using index。

这里提到了覆盖索引，extra列会出现using index。

extra还有其他比较重要的信息：

using filesort：用到了外部的索引排序，即MySQL无法利用索引完成排序。

using temptory：使用了临时表。

using where：使用了where过滤。

### JMM相关知识

> 摘自https://blog.csdn.net/weixin_40970862/article/details/118679035

问题引入（以下代码）

```java
public class Math {
    static boolean flag = false;
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            while (!flag) {
            }
        }).start();
        TimeUnit.SECONDS.sleep(2);
        new Thread(() -> flagToTrue()).start();
    }
    public static void flagToTrue() {
        flag = true;
    }
}
```

上面代码中，静态变量flag的值，在被两个线程调用的时候，flag值得副本被拷贝到各自线程的专属内存空间中，当第二个线程去修改flag值之后并把其写回到主存的之后，第一个线程中私有的flag值仍为false，并未检测到flag值得变化，所以第一个线程不会停止

* 所以引出了JMM模型图

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712165857491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk3MDg2Mg==,size_16,color_FFFFFF,t_70#pic_center)

线程使用共享变量的时候不是直接操作主内存的，是保持一份共享变量的副本，到该线程的工作内存中，来操作这个变量的。   

> 补充：现代的冯诺依曼机是这样的，CPU中除了寄存器之外还存在Cache高速缓存来弥补CPU和内存之间的速度差距，但CPU中的缓存去读取主存（三级缓存）的时候，会将变量的值存入到每个核心（线程）各自独享的Cache中，所以在多核心同时并发的时候会造成数据读取的问题，所以就会有些指令或者操作来防止这种事情发生

* JMM中数据的原子操作

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021071217021769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk3MDg2Mg==,size_16,color_FFFFFF,t_70#pic_center)

* 下图中表示了JMM数据的原子操作的过程

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712170343246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk3MDg2Mg==,size_16,color_FFFFFF,t_70#pic_center)

> volatile关键字（MESI）
> 总线缓存一致性协议：保证了线程修改数据完成之后，一定第一时间同步到主存中，会使用到CPU0总线嗅探机制（监听总线），会监听它感兴趣的值
> 当开启总线嗅探机制之后，线程2修改完成值写到主内存的时候，其线程1中的相关值会立刻失效，并触发线程1使用该值得得时候要去主内存中重新拿值

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712170504728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk3MDg2Mg==,size_16,color_FFFFFF,t_70#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712170553734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk3MDg2Mg==,size_16,color_FFFFFF,t_70#pic_center)

**Volatile的实现是通过汇编的前缀指令lock实现的**

当变量的值通过store和read的原子操作之前，加入关键字volatile之后，在store之前会有一步的lock操作，锁住主内存以防止并发问题的发生，当执行完store和read操作将变量值写入主内存之后，会进行unlock操作释放主内存的锁，其他线程才可以读和写

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712170706214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk3MDg2Mg==,size_16,color_FFFFFF,t_70#pic_center)

并发编程的三大特征：可见性，有序性，原子性

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712170757388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk3MDg2Mg==,size_16,color_FFFFFF,t_70#pic_center)


CPU在认为其不影响单线程执行结果的时候，会对指令的顺序进行重拍，结果就是会发生下图中的代码a = 1， b = 1的结果

```
	private static int a = 0, b = 0, x = 0, y = 0;

    for (int i = 0; i < 100000; i++) {
        Thread thread = new Thread(() -> {
            a = y;
            x = 1;
        });
        Thread thread1 = new Thread(() -> {
            b = x;
            y = 1;
        });
    }
```
> as-if-serial原则是数据相关的问题，happens-before是保证操作执行的先后顺序不能让程序出错
>

DCL单例模式的双重检测锁会造成对象的半初始化，从而造成图读的值和真正想拿到的值不同，加入volatile关键字会防止指令重排，从而不让这种问题发生

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712171156999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk3MDg2Mg==,size_16,color_FFFFFF,t_70#pic_center)

> new一个对象的过程是如下的
> instance = new DoubleCheckLockSingleton()；的汇编层面的实现
> 17行 new指令，开辟一块内存空间
> 21行 invokespecial指令，执行初始化方法，给内存中的变量赋值
> 24行 putstaitic指令，将初始化好的内存地址赋给变量，让变量指向该内存地址
> 当CPU进行指令重排的话，会发生下列的问题
> 17行 new指令，开辟一块内存空间
> 24行 putstaitic指令，将开辟好的内存地址赋给变量，让变量指向该内存
> 21行 invokespecial指令，执行初始化方法，给内存中的变量赋值
> 以上条件发送的CPU指令重排的情况，当线程A执行到24行的时候，对象还是初始化状态，线程B去读取对象是否为空（变量是否已经指向堆中的对象）的时候，发现变量以及有指针指向对象，故读到的值为对象初始化的值，并不是真正想要的值，这个情况，称为对象的半初始化状态

内存屏障：当判断两个行代码不可以重排序的话，在两行代码中间加入一个标记告诉CPU代码不能重新排序，加的标记就是内存屏障
var a = 1;
======（模拟内存屏障）
var b = 1;
如果情况是如图的话，则就表示赋值语句赋值a,b的顺序不能颠倒
当然JVM定义的内存屏障的类型也和CPU中的

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712182205302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk3MDg2Mg==,size_16,color_FFFFFF,t_70#pic_center)

加lock锁之后实现内存屏障的时候，HotSopt虚拟机会在代码的汇编层面加上lock汇编前缀来实现

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712182808287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk3MDg2Mg==,size_16,color_FFFFFF,t_70#pic_center)

根据Java的HotSopt虚拟机的实现C++代码可以得知

> 补充：JVM的跨平台性是因为不同的操作系统和CPU上有这不同的实现来完成的的
>

### 什么是函数式接口

函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。

函数式接口可以被隐式转换为 lambda 表达式。

Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。

如定义了一个函数式接口如下：

```
@FunctionalInterface
interface GreetingService 
{
    void sayMessage(String message);
}
```

那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：

```
GreetingService greetService1 = message -> System.out.println("Hello " + message);
```

函数式接口可以对现有的函数友好地支持 lambda。

### 什么是函数方法？

```
面向对象的语言叫方法，面向过程的语言叫函数。

在java中没有函数这么一说，只有方法一说。实际上方法就是函数，函数就是方法，只是在不同的语言不同的称呼而已。

一句话告诉你如何区分函数与方法：函数是大家的函数，方法是类的方法。

如何区分一个ITer是设计师还是码工。看看他是在调别人的库，还是自己写出JAR包跟别人分享。

感觉差的不是一个级别而已啊。

一个东西，用对象调用的叫方法，直接调函数名的叫函数。

c语言等语言里叫函数，面向对象编程，函数写到类里边就叫做方法，函数可以直接调用，对象中的方法一般都有指针this指向它，但是有时一些方法实在不需要写到类里边，所以面向对象的语言有了静态方法，不过这个概念没必要纠结，用的多了自然就明白啦。

函数Function，过程Procedure，方法Method，你可以简单把他们当成同一个概念：都是由若干语句组成的一个可执行代码体。

函数：Function（面向过程语言教程的英文原版，是否有一个把Function翻译为Method的？）

方法：Method（只有不地道的面向对象语言教程才会把Method叫做Function）

意思一样的，可能就是方法偏重于类，也就是面向对象设计的，注重每个函数的功能所以叫方法；而函数偏重于面向过程，有可能是功能描述也有能不是，两者都有是看编程者自己怎么看的。
```

### 数据库并发怎么控制？

#### 事物特性

```
事务有个基本特性：这一组操作要么一起生效，要么都不生效，事务执行过程中如遇错误，已经执行的操作要全部撤回，这就是事务的原子性。

事务只要提交了，它的结果就不能改变了，即使遇到系统宕机，重启后数据库的状态与宕机前一致，这就是事务的持久性。

隔离性让用户可以专注于单个事务的逻辑，不用考虑并发执行的影响。数据库通过并发控制机制保证隔离性。由于隔离性对事务的执行顺序要求较高，很多数据库提供了不同选项，用户可以牺牲一部分隔离性，提升系统性能。这些不同的选项就是事务隔离级别。

数据库反映的是真实世界，真实世界有很多限制，事务执行，不能打破这些约束，保证事务从一个正确的状态转移到另一个正确的状态，这就是一致性。不同与前三种性质完全由数据库实现保证，一致性既依赖于数据库实现（原子性、持久性、隔离性也是为了保证一致性），也依赖于应用端编写的事务逻辑。
```

#### 事物隔离级别

```
1.Serializable（序列化）
系统中所有的事务以串行地方式逐个执行，所以能避免所有数据不一致情况。
但是这种以排他方式来控制并发事务，串行化执行方式会导致事务排队，系统的并发量大幅下降，使用的时候要绝对慎重。

2.Repeatable read（可重复读）
一个事务一旦开始，事务过程中所读取的所有数据不允许被其他事务修改。
一个隔离级别没有办法解决“幻影读”的问题。
因为它只“保护”了它读取的数据不被修改，但是其他数据会被修改。如果其他数据被修改后恰好满足了当前事务的过滤条件（where语句），那么就会发生“幻影读”的情况。
其他两种事务隔离等级为：
3.Read Committed（已提交读）
一个事务能读取到其他事务提交过(Committed)的数据。
一个事务在处理过程中如果重复读取某一个数据，而且这个数据恰好被其他事务修改并提交了，那么当前重复读取数据的事务就会出现同一个数据前后不同的情况。
在这个隔离级别会发生“不可重复读”的场景。
4.Read Uncommitted（未提交读）
一个事务能读取到其他事务修改过，但是还没有提交的(Uncommitted)的数据。
数据被其他事务修改过，但还没有提交，就存在着回滚的可能性，这时候读取这些“未提交”数据的情况就是“脏读”。
在这个隔离级别会发生“脏读”场景。
```

#### 基于两阶段锁的并发控制

##### 2.1 2PL

既然要保证操作按正确的顺序执行，最容易想到的方法就是加锁保护访问对象。数据库系统的锁管理器模块，专门负责给访问对象加锁和释放锁，保证**只有持有锁的事务，才能操作相应的对象**。锁可以分为两类：S-Lock和X-Lock，S-Lock是读请求使用的共享锁，X-Lock是写请求使用的排他锁。它们的兼容性如下：操作同一个对象，只有两个读请求相互兼容，可以同时执行，读写和写写操作都会因为锁冲突而串行执行。

![img](https://pic4.zhimg.com/80/v2-7cc5e5e14672651c80ec66a3fa7e311b_720w.jpg)

2PL（Two-phase locking）是数据库最常见的基于锁的并发控制协议，顾名思义，它包含两个阶段：

- 阶段一：Growing，事务向锁管理器请求它需要的所有锁（存在加锁失败的可能）。
- 阶段二：Shrinking，事务释放Growing阶段获取的锁，不允许再请求新锁。

为什么加锁和放锁要泾渭分明地分为两个阶段呢？

2PL并发控制目的是为了达到serializable，如果并发控制不事先将所有需要的锁申请好，而是释放锁后，还允许再次申请锁，可能出现事务内两次操作同一对象之间，其它事务修改这一对象（如下图所示），进而无法达到conflict serializable，出现不一致的现象（下面的例子是lost update）。

![img](https://pic2.zhimg.com/80/v2-7bd85e71c2d4486790e1a7f9096f2e19_720w.jpg)

2PL可以保证conflict serializability，因为事务必须拿到所有需要的锁才能执行。例如**正在执行**的事务A与事务B冲突，事务B要么已经执行完，要么还在等待。因此那些冲突操作的执行顺序，与BA或AB串行执行时冲突操作执行顺序一致。

所以，数据库只要采用2PL就能保证一致性和隔离性了吗？来看一下这个例子：

![img](https://pic2.zhimg.com/80/v2-e83e68c18d1562d770035dc5563b1191_720w.jpg)

以上执行顺序是符合2PL的，但T2读到了未提交的数据。如果此时T1回滚，则会引发**级联回滚**（T1的更改，不能被任何事务看到）。因此，数据库往往使用的是加强版的S(trong)S(trict)2PL，它相较于2PL有一点不同：shrinking阶段，只能在事务结束后再释放锁，完全杜绝了事务未提交的数据被读到。

##### 2.2 死锁处理

并发事务加锁放锁必然绕不开一个问题--死锁：事务1持有A锁等B锁，事务2持有B锁等A锁。目前解决死锁问题有两种方案：

- Deadlock Detection：

数据库系统根据waits-for图记录事务的等待关系，其中点代表事务，有向边代表事务在等待另一个事务放锁。当waits-for图出现环时，代表死锁出现了。系统后台会定时检测waits-for图，如果发现环，则需要选择一个合适的事务abort。

![img](https://pic2.zhimg.com/80/v2-80f127ca246352339d345c2bdbbc9cdd_720w.jpg)

- Deadlock Prevention：

当事务去请求一个已经被持有的锁时，数据库系统为防止死锁，杀死其中一个事务（一般持续越久的事务，保留的优先级越高）。这种防患于未然的方法不需要waits-for图，但提高了事务被杀死的比率。

##### 2.3 意向锁

如果只有行锁，那么事务要更新一亿条记录，需要获取一亿个行锁，将占用大量的内存资源。我们知道锁是用来保护数据库内部访问对象的，这些对象根据大小可能是：属性（Attribute）、记录（Tuple）、页面（Page）、表（Table），相应的锁可分为行锁、页面锁、表锁（没人实现属性锁，对于OLTP数据库，最小的操作单元是行）。对于事务来讲，获得最少量的锁当然是最好的，比如更新一亿条记录，或许加一个表锁就足够了。

层次越高的锁（如表锁），可以有效减少对资源的占用，显著减少锁检查的次数，但会严重限制并发。层次越低的锁（如行锁），有利于并发执行，但在事务请求对象多的情况下，需要大量的锁检查。数据库系统为了解决高层次锁限制并发的问题，引入了意向（Intention）锁的概念：

- Intention-Shared (IS)：表明其内部一个或多个对象被S-Lock保护，例如某表加IS，表中至少一行被S-Lock保护。
- Intention-Exclusive (IX)：表明其内部一个或多个对象被X-Lock保护。例如某表加IX，表中至少一行被X-Lock保护。
- Shared+Intention-Exclusive (SIX)：表明内部至少一个对象被X-Lock保护，并且自身被S-Lock保护。例如某个操作要全表扫描，并更改表中几行，可以给表加SIX。读者可以思考一下，为啥没有XIX或XIS

意向锁和普通锁的兼容关系如下所示：

![img](https://pic3.zhimg.com/80/v2-9e862fa0933b027c590f12274ef21512_720w.jpg)

意向锁的好处在于：当表加了IX，意味着表中有行正在修改。（1）这时对表发起DDL操作，需要请求表的X锁，那么看到表持有IX就直接等待了，而不用逐个检查表内的行是否持有行锁，**有效减少了检查开销。**（2）这时有别的读写事务过来，由于表加的是IX而非X，并不会阻止对行的读写请求（先在表上加IX，再去记录上加S/X），事务如果没有涉及已经加了X锁的行，则可以正常执行，增大了系统的并发度。

#### 基于Timing Order（T/O）的并发控制

为每个事务分配timestamp，并以此决定事务执行顺序。当事务1的timestamp小于事务2时，数据库系统要保证事务1先于事务2执行。timestamp分配的方式包括：（1）物理时钟；（2）逻辑时钟；（3）混合时钟。

##### 3.1 Basic T/O

基于T/O的并发控制，读写不需加锁， 每行记录都标记了**最后修改和读取它的事务的timestamp**。当事务的timestamp小于记录的timestamp时（不能读到”未来的”数据），需要abort后重新执行。假设记录X上标记了读写两个timestamp：WTS(X)和RTS(X)，事务的timestamp为TTS，可见性判断如下：

读：

- TTS < WTS(X)：该对象对该事务不可见，abort事务，取一个新timestamp重新开始。
- TTS > WTS(X)：该对象对事务可见，更新RTS(X) = max(TTS,RTS(X))。为了满足repeatable read，事务复制X的值。
- 为了防止读到脏数据，可以在记录上做特殊标记，读请求需等待事务提交后再去读。

写：

- TTS < WTS(X) || TTS < RTS(X)：abort事务，重新开始。
- TTS > WTS(X) && TTS > RTS(X)： 事务更新X，WTS(X) = TTS。

这里之所以要求TTS > RTS(X)，是为了防止如下情况：读请求的时间戳为rts，已经读过X，时间戳设为RTS(X)=rts，如果新事务的TTS < RTS(X)，并且更新成功，则rts读请求再来读一次就看到新的更改了，违反了repeatable read，因此这是为了避免读写冲突。记录上存储了最后的读写时间，可以保证conflict serializable.

这种方式也能避免write skew，例如：初始状态，X和Y两条记录，X=-3，Y=5，X+Y >0，RTS(X)=RTS(Y)=WTS(X)=WTS(Y)=0。事务T1的时间戳为TTS1=1，事务T2的时间戳TTS2=2。

![img](https://pic2.zhimg.com/80/v2-6874d53c828173a8a67dad6b54db70c1_720w.jpg)

它缺陷包括：

- 长事务容易饿死，因为长事务的timestamp偏小，大概率会在执行一段时间后读到更新的数据，导致abort。
- 读操作也会产生写（写RTS）。

#### 基于Validation（OCC）的并发控制

执行过程中，每个事务维护自己的写操作（Basic T/O在事务执行过程中写就将数据写入DB）和相应的RTS/WTS，提交时判断自己的更改是否和数据库中已存在的数据冲突，如果不冲突才写入DB。OCC分为三个阶段：

- Read & Write Phase：即读写阶段，事务维护读的结果和即将提交的更改，以及写入记录的RTS和WTS。
- Validation Phase：检查事务是否与数据库中的数据冲突。
- Write Phase：不冲突就写入，冲突就abort,restart。

Read & Write Phase结束，进入Validation Phase相当于事务准备完成，进入提交阶段了，进入Validation Phase的时间被选做记录行的时间戳，来定序。不用事务开始时间是因为：事务执行时间可能较长，导致后开始的事务可能先提交，这会加大事务冲突的概率，较小时间戳的事务后写入数据库，肯定会abort。

##### Validation过程

假设当前只有两个事务T1和T2，并修改了相同数据行，T1的时间戳 < T2的时间戳（即validation顺序：T1 < T2，对用户而言，T1先发生于T2），则有如下情况：

（1）T1在validate阶段，T2还在Read & Write Phase。此时只要T1和T2已经发生的读写没有冲突，就可以提交。

- 如果WS(T1) ∩ (RS(T2) ∪ WS(T2)) = ∅，说明T2和T1写的记录无冲突，validation通过，可以写入。
- 否则，T2与T1之间存在读写冲突或写写冲突，T1需要回滚。读写冲突：T2读到了T1写之前的版本，T1提交后，它可能读到T1写的版本，不可重复读。写写冲突：T2有可能在旧版本基础上更新，再次写入，造成T1的更新丢失。

（2）T1完成validate阶段，进入write阶段直到提交完成，这已经是不可逆的了。T2在T1进入write phase之前的读写，肯定和T1的操作不冲突（因为T1 validation通过了）。T2之后继续的读写操作，有可能冲突与T1要提交的操作，因此T2进入validate阶段：

- 如果WS(T1) ∩ RS(T2)= ∅，说明T2没读到T1写的记录，validation通过，T2可以写入。（为什么不验证WS(T2)了呢？WS(T1)已经提交了，且它的时间戳小于WS(T2)，WS(T2)里之前的一部分肯定没有冲突，之后的一部分，因为没有读过T1的写入的对象，写进去也没问题，不会覆盖WS（T1）的写）
- 否则，T2与T1之间存在读写冲突和写写冲突，T2需要回滚。读写冲突：T2读到了T1写之前的版本，T1提交后，它可能读到T1写的版本，不可重复读。写写冲突：T2有可能在旧版本基础上更新，再次写入，造成T1的更新丢失。

#### 基于MVCC的并发控制

> https://segmentfault.com/a/1190000037557620

![image-20220222215822519](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220222215822519.png)

![image-20220222215856265](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220222215856265.png)

![image-20220222215801577](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220222215801577.png)



数据库维护了一条记录的多个物理版本。事务写入时，创建写入数据的新版本，读请求依据事务/语句开始时的快照信息，获取当时已经存在的最新版本数据。它带来的最直接的好处是：写不阻塞读，读也不阻塞写，读请求永远不会因此冲突失败（例如单版本T/O）或者等待（例如单版本2PL）。对数据库请求来说，读请求往往多于写请求。主流的数据库几乎都采用了这项优化技术。

MVCC是读和写请求的优化技术，没有完全解决数据库并发问题，它需要与前述的几种并发控制技术组合，才能提供完整的并发控制能力。常见的并发控制技术种类包括：MV-2PL，MV-T/O和MV-OCC，它们的特点如下表：

![img](https://pic4.zhimg.com/80/v2-b2d7ea29cba9e90193f2f34cd84175db_720w.jpg)

MVCC还有两个关键点需要考虑：多版本数据的存储和多余多版本数据的回收。

多版本数据存储方式，大致可以分为两类：（1）Append only的方式，新旧版本存储在同一个表空间，例如基于LSM-Tree的存储引擎。（2）主表空间记录最新版本数据，前镜像记录在其它表空间或数据段，例如InnoDB的多版本信息记录在undo log。多版本数据回收又称为垃圾回收（GC），那些没有机会再被任何读请求获取的旧版本记录，应该被及时删除。

#### 总结

本文依据冲突处理的时机（乐观程度），依次介绍了基于锁（在事务开始前预防冲突）、基于T/O（在事务执行中判断冲突）和基于Validation（在事务提交时验证冲突）的事务并发控制机制。不同的实现适用于不同的workload，并发冲突小的workload，当然适合更乐观的并发控制方式。而MVCC可以解决只读事务和读写事务之间相互阻塞的问题，提高了事务的并发读，被大多数主流数据库系统采用。

### Spring el表达式

```

```









多线程如何优化.

什么是开闭原则？
什么是开，什么是闭？

```
对扩展开放，对修改关闭
```

什么是包装模式？

平时接触过哪些设计模式？

后台server怎么推送消息给H5页面

Eurrake保证了cap中的哪些特性



Quartz定时器怎么实现

Mybaits和数据库连接池相关知识

```
项目中有哪些难点以及怎么遇到的问题
在项目中你遇到过什么问题.
在项目中你如何与别人沟通.
登陆问的多
Timer有哪些重要的API以及这些API是怎么实现的
Netty相关知识 RabbitMQ zookeeper dubbo相关知识
nacos 
```

### 排序算法有几种复杂度怎么样

![image](https://user-images.githubusercontent.com/43489916/154788217-a39a7003-28ba-4614-a1cc-b5d908160235.png)

### 谈谈你对算法的认识

```
解决某个问题的方法、步骤
有限性（Finiteness）：一个算法必须保证执行有限步之后结束。
确切性（Definiteness）： 一个算法的每一步骤必须有确切的定义。
输入（Input）：一个算法有零个或多个输入，以刻画运算对象的初始情况，所谓零个输入是指算法本身给定了初始条件。
输出（Output）：一个算法有一个或多个输出。没有输出的算法毫无意义。
可行性（Effectiveness）： 一个算法的任何计算步骤都是可以被分解为基本可执行的操作，每个操作都能够在有限时间内完成。
```

### 什么是最优二叉树？

```
给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
```

![img](https://img-blog.csdnimg.cn/img_convert/5f9c080f35fce34fcdd206a170e95e3a.png)

### 怎么实现最优二叉树？

```
第一次取所有节点中权值最小的节点，他们两个作为子节点，计算父节点的权值（他们两个子节点权值和），然后将父节点这个二叉树放入节点中，在从中选出权值最小的两个进行计算父节点权值放入其中
```

